# 15. 에러 처리 및 사용자 피드백

**프로젝트**: Saju피아 - AI 기반 사주팔자 분석 SaaS
**작성일**: 2025-12-12
**버전**: 1.0

---

## 개요

모든 사용자 액션에서 발생 가능한 에러를 HTTP 상태 코드별로 일관되게 처리하고, 사용자에게 명확하고 친화적인 피드백을 제공합니다.

---

## 비즈니스 목표

1. **사용자 경험 향상**: 에러 상황에서도 명확한 안내로 혼란 최소화
2. **시스템 안정성**: 모든 에러를 적절히 핸들링하여 앱 크래시 방지
3. **운영 효율성**: 에러 로그를 통한 신속한 문제 파악 및 대응
4. **신뢰도 구축**: 일관된 에러 처리로 서비스 신뢰도 향상

---

## 사용자 스토리

### 스토리 1: 네트워크 오류 처리
**As a** 사용자
**I want to** 네트워크 오류 시 명확한 안내를 받고
**So that** 문제를 인지하고 재시도할 수 있다

### 스토리 2: 인증 오류 처리
**As a** 사용자
**I want to** 인증이 만료되면 자동으로 로그인 페이지로 이동하고
**So that** 다시 로그인하여 작업을 계속할 수 있다

### 스토리 3: 권한 오류 처리
**As a** 사용자
**I want to** 권한 없는 접근 시 적절한 안내를 받고
**So that** 다른 페이지로 이동할 수 있다

### 스토리 4: 서버 오류 처리
**As a** 사용자
**I want to** 서버 오류 시 일시적 문제임을 알고
**So that** 잠시 후 재시도할 수 있다

---

## 입력 (Input)

### 에러 발생 시점
- 모든 API 호출 시
- 외부 서비스 연동 시 (Clerk, Gemini, 토스페이먼츠)
- 페이지 접근 시
- 폼 제출 시

### 에러 유형
- **클라이언트 에러**: 네트워크 오류, 요청 타임아웃
- **인증 에러**: 401 Unauthorized
- **권한 에러**: 403 Forbidden
- **리소스 에러**: 404 Not Found
- **충돌 에러**: 409 Conflict
- **서버 에러**: 500 Internal Server Error, 502 Bad Gateway, 503 Service Unavailable

---

## 처리 (Processing)

### 에러 핸들링 플로우

1. **에러 캐치**
   - 모든 API 요청에 try-catch 또는 .catch() 추가
   - Promise rejection 핸들링
   - Axios/Fetch interceptor 활용

2. **에러 분류**
   - HTTP 상태 코드 확인
   - 에러 타입 식별
   - 에러 메시지 추출

3. **로깅**
   - 에러 상세 정보 콘솔/서버 로그에 기록
   - 사용자 컨텍스트 포함 (user_id, action, timestamp)
   - 민감 정보 마스킹

4. **사용자 피드백**
   - 상태 코드별 메시지 표시
   - 토스트, 모달, 또는 인라인 메시지
   - 액션 버튼 제공 (재시도, 돌아가기 등)

5. **복구 액션**
   - 자동 재시도 (특정 에러)
   - 페이지 리다이렉트
   - 폴백 UI 표시

---

## 출력 (Output)

### HTTP 상태 코드별 처리

#### 네트워크 오류 (Network Error)
**상황**: 인터넷 연결 끊김, DNS 실패
**메시지**: "인터넷 연결을 확인해주세요"
**액션**:
- "다시 시도" 버튼 (재요청)
- 자동 재시도 (최대 3회, 지수 백오프)

#### 400 Bad Request
**상황**: 잘못된 요청 파라미터
**메시지**: "요청 형식이 올바르지 않습니다"
**액션**:
- 폼 입력값 검증 에러 표시
- 입력 필드 하이라이트

#### 401 Unauthorized
**상황**: 인증 토큰 만료 또는 없음
**메시지**: "로그인이 필요합니다"
**액션**:
- 자동으로 Clerk 로그인 페이지로 리다이렉트
- 로그인 완료 후 원래 페이지로 복귀 (returnUrl 설정)

#### 403 Forbidden
**상황**: 권한 없는 리소스 접근
**메시지**: "접근 권한이 없습니다"
**액션**:
- "대시보드로 돌아가기" 버튼
- 에러 페이지 표시

#### 404 Not Found
**상황**: 존재하지 않는 리소스 요청
**메시지**: "요청하신 페이지를 찾을 수 없습니다"
**액션**:
- 404 에러 페이지 표시
- "홈으로 가기" 버튼
- "대시보드로 가기" 버튼

#### 409 Conflict
**상황**: 중복된 요청, 상태 충돌
**메시지**: 상황별 구체적 메시지
- "이미 Pro 구독 중입니다"
- "이미 취소 예약되었습니다"
**액션**:
- 현재 상태 페이지로 리다이렉트

#### 429 Too Many Requests
**상황**: API 요청 제한 초과
**메시지**: "너무 많은 요청을 보냈습니다. 잠시 후 다시 시도해주세요"
**액션**:
- Retry-After 헤더 확인 후 대기
- 카운트다운 타이머 표시

#### 500 Internal Server Error
**상황**: 서버 내부 오류
**메시지**: "일시적인 오류가 발생했습니다. 잠시 후 다시 시도해주세요"
**액션**:
- "다시 시도" 버튼
- 고객센터 연락처 안내

#### 502 Bad Gateway / 503 Service Unavailable
**상황**: 서버 또는 외부 서비스 장애
**메시지**: "서비스가 일시적으로 이용 불가합니다. 잠시 후 다시 시도해주세요"
**액션**:
- 자동 재시도 (최대 3회)
- 서비스 상태 페이지 링크 (선택)

#### 504 Gateway Timeout
**상황**: 요청 처리 시간 초과
**메시지**: "요청 처리 시간이 초과되었습니다. 다시 시도해주세요"
**액션**:
- "다시 시도" 버튼

---

## 기능별 에러 시나리오

### 신규 검사 생성 시

#### 시나리오 1: 잔여 횟수 부족 (403)
**메시지**: "검사 횟수를 모두 사용했습니다"
**상세**:
- Free: "Pro로 업그레이드하면 월 10회 고품질 검사를 이용하실 수 있습니다"
- Pro: "다음 결제일(YYYY-MM-DD)에 횟수가 초기화됩니다"
**액션**:
- Free: "Pro로 업그레이드" 버튼 → `/subscription`
- Pro: "확인" 버튼 → 모달 닫기

#### 시나리오 2: Gemini API 타임아웃 (504)
**메시지**: "AI 서버가 응답하지 않습니다. 잠시 후 다시 시도해주세요"
**액션**:
- 잔여 횟수 차감 롤백
- "다시 시도" 버튼

#### 시나리오 3: Gemini API 에러 (500/429)
**메시지**: "일시적으로 서비스 이용이 제한되었습니다. 잠시 후 다시 시도해주세요"
**액션**:
- 잔여 횟수 차감 롤백
- `/dashboard`로 리다이렉트

### Pro 구독 시작 시

#### 시나리오 1: 이미 Pro 구독 중 (409)
**메시지**: "이미 Pro 구독 중입니다"
**액션**:
- `/subscription`로 리다이렉트

#### 시나리오 2: 결제 실패 (500)
**메시지**: "결제에 실패했습니다. 결제 수단을 확인해주세요"
**액션**:
- "다시 시도" 버튼
- 빌링키 삭제 처리

#### 시나리오 3: 토스페이먼츠 타임아웃 (504)
**메시지**: "일시적인 오류가 발생했습니다. 잠시 후 다시 시도해주세요"
**액션**:
- 빌링키 삭제 시도
- "다시 시도" 버튼

### 대시보드 조회 시

#### 시나리오 1: API 요청 실패 (Network Error)
**메시지**: "검사 내역을 불러올 수 없습니다"
**액션**:
- "다시 시도" 버튼
- 자동 재시도 (최대 3회)

#### 시나리오 2: 인증 만료 (401)
**처리**: 자동으로 로그인 페이지로 리다이렉트
**복귀**: 로그인 후 `/dashboard`로 자동 이동

### 분석 상세보기 시

#### 시나리오 1: 존재하지 않는 검사 ID (404)
**메시지**: "검사를 찾을 수 없습니다"
**액션**:
- "대시보드로 돌아가기" 버튼

#### 시나리오 2: 다른 사용자의 검사 접근 (403)
**메시지**: "접근 권한이 없습니다"
**액션**:
- "대시보드로 돌아가기" 버튼

---

## UI/UX 가이드라인

### 에러 메시지 표시 방법

#### 토스트 메시지
**사용 시기**: 일시적 정보, 성공/실패 피드백
**특징**:
- 화면 상단 또는 하단에 3-5초간 표시
- 자동으로 사라짐
- 여러 개 쌓이지 않도록 관리
**예시**: "검사가 완료되었습니다", "구독 취소가 예약되었습니다"

#### 모달 (Dialog)
**사용 시기**: 중요한 에러, 사용자 액션 필요
**특징**:
- 화면 중앙에 오버레이
- 명시적으로 닫기 전까지 표시
- 명확한 CTA 버튼
**예시**: 잔여 횟수 부족, 결제 실패

#### 인라인 메시지
**사용 시기**: 폼 입력 검증 에러
**특징**:
- 입력 필드 바로 아래 표시
- 빨간색 텍스트
- 필드 하이라이트
**예시**: "이름은 필수 입력입니다", "생년월일은 오늘 이전이어야 합니다"

#### 에러 페이지
**사용 시기**: 404, 500 등 페이지 레벨 에러
**특징**:
- 전체 페이지 대체
- 일러스트 또는 이미지 포함
- 홈/대시보드로 이동 버튼
**예시**: 404 Not Found, 500 Server Error

### 메시지 작성 원칙

1. **명확성**: 무엇이 잘못되었는지 명확히 표현
2. **친절성**: 비난하지 않고 도움이 되는 톤
3. **실행 가능성**: 사용자가 무엇을 해야 하는지 안내
4. **간결성**: 불필요한 기술 용어 배제

**좋은 예시**:
- "인터넷 연결을 확인해주세요"
- "검사 횟수를 모두 사용했습니다. Pro로 업그레이드해보세요"

**나쁜 예시**:
- "Error: Network request failed with status code 0"
- "Unauthorized access detected"

---

## 로깅 전략

### 클라이언트 로깅

**콘솔 로그 (개발 환경)**:
```typescript
console.error('[ERROR]', {
  timestamp: new Date().toISOString(),
  userId: user?.id,
  action: 'createTest',
  error: {
    message: error.message,
    status: error.response?.status,
    data: error.response?.data
  }
});
```

**에러 트래킹 서비스 (프로덕션)**:
- Sentry 또는 LogRocket 등 사용 권장
- 에러 스택 트레이스 자동 수집
- 사용자 세션 재생
- 알림 설정

### 서버 로깅

**구조화된 로그**:
```typescript
logger.error({
  timestamp: new Date().toISOString(),
  userId: req.user?.id,
  endpoint: req.url,
  method: req.method,
  error: {
    message: error.message,
    stack: error.stack,
    statusCode: 500
  }
});
```

**민감 정보 마스킹**:
- billing_key: `billing_key_***1234`
- email: `us***@example.com`
- 비밀번호, 토큰 등은 절대 로깅 금지

---

## 재시도 로직

### 자동 재시도 대상
- 네트워크 오류
- 502 Bad Gateway
- 503 Service Unavailable
- 504 Gateway Timeout

### 재시도 전략
- **최대 횟수**: 3회
- **지수 백오프**: 1초, 2초, 4초 대기
- **재시도 조건**: 멱등성 보장되는 GET, PUT 요청만

**예시 코드 (의사코드)**:
```typescript
async function retryRequest(fn, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (i === maxRetries - 1 || !isRetryableError(error)) {
        throw error;
      }
      await sleep(2 ** i * 1000); // 1s, 2s, 4s
    }
  }
}
```

---

## 엣지 케이스

### Case 1: 연속된 에러 발생
**상황**: 사용자가 3회 이상 연속으로 같은 에러 경험
**처리**:
- 에러 횟수 추적 (로컬 스토리지 또는 상태)
- 3회 이상 시 특별 메시지
**메시지**: "계속 문제가 발생합니다. 고객센터에 문의해주세요"
**액션**:
- 고객센터 이메일/전화 표시
- "대시보드로 가기" 버튼

### Case 2: 여러 탭에서 동시 사용 중 에러
**상황**: 한 탭에서 구독 취소 후 다른 탭에서 검사 시도
**처리**:
- 서버에서 최신 구독 상태 확인
- 403 Forbidden 반환
**메시지**: "구독 상태가 변경되었습니다. 페이지를 새로고침해주세요"

### Case 3: 외부 서비스 동시 장애
**상황**: Gemini와 토스페이먼츠가 동시 장애
**처리**:
- 서비스별 에러 구분
- 우선순위에 따라 에러 표시
**메시지**: "외부 서비스 연동에 문제가 발생했습니다. 잠시 후 다시 시도해주세요"

### Case 4: 긴급 점검 모드
**상황**: 서버 긴급 점검 중
**처리**:
- 모든 API 503 반환
- 환경변수로 점검 모드 설정
**메시지**: "현재 시스템 점검 중입니다. [종료 시간]에 다시 이용해주세요"
**UI**: 전체 페이지 점검 안내 화면

---

## 성공 기준 (Acceptance Criteria)

### 필수
- [ ] 모든 API 호출에 에러 핸들링 추가
- [ ] HTTP 상태 코드별 사용자 피드백 구현
- [ ] 401 에러 시 자동 로그인 리다이렉트
- [ ] 네트워크 오류 시 재시도 로직 구현
- [ ] 에러 로그 서버에 기록
- [ ] 404, 500 에러 페이지 구현

### 권장
- [ ] Sentry 등 에러 트래킹 서비스 연동
- [ ] 에러 발생 시 관리자 알림 (이메일/슬랙)
- [ ] 긴급 점검 모드 구현
- [ ] 에러 대시보드 (관리자용)

---

## 관련 페이지

- **모든 페이지**: 에러 핸들링 공통 적용
- **대시보드** (`/dashboard`): 검사 내역 조회 에러
- **새 검사** (`/new-test`): 검사 생성 에러
- **분석 상세보기** (`/analysis/[id]`): 리소스 접근 에러
- **구독 관리** (`/subscription`): 결제 에러

---

## 연관 기능

- **1. 신규 사용자 회원가입**: Clerk Webhook 실패 처리
- **2. 새 검사 생성**: Gemini API 에러 처리
- **5. Pro 구독 시작**: 토스페이먼츠 에러 처리
- **8. 정기결제 자동 실행**: 결제 실패 처리
- **13. Global Navigation 업데이트**: 상태 동기화 실패 처리

---

## 외부 연동

### Clerk
- **401 에러**: 토큰 만료 → 자동 로그인 리다이렉트
- **Webhook 실패**: Clerk 자동 재시도 → 서버 로그 기록

### Gemini API
- **429 Rate Limit**: "일시적으로 서비스 이용이 제한되었습니다"
- **500 Server Error**: 재시도 후 실패 시 사용자 알림

### 토스페이먼츠
- **결제 실패**: 빌링키 삭제 + 구독 해지
- **타임아웃**: 재시도 후 실패 시 고객센터 안내

### Supabase
- **연결 실패**: 자동 재시도 + "데이터베이스 연결 오류" 알림
- **RLS 위반**: 403 Forbidden → "접근 권한이 없습니다"

---

## 기술 요구사항

### 클라이언트
- Error Boundary (React)
- Axios/Fetch Interceptor
- Toast 라이브러리 (예: react-hot-toast)
- 에러 상태 관리 (React Context 또는 Zustand)

### 서버
- Express/Next.js Error Middleware
- Winston 또는 Pino 로거
- HTTP 상태 코드 유틸리티
- 에러 클래스 정의 (CustomError)

---

## 보안 고려사항

1. **에러 메시지에서 민감 정보 제거**
   - 스택 트레이스는 개발 환경에만 노출
   - 데이터베이스 스키마 정보 숨김
   - API 키, 토큰 절대 노출 금지

2. **Rate Limiting**
   - 동일 IP에서 과도한 에러 발생 시 일시 차단
   - 429 Too Many Requests 반환

3. **로그 보안**
   - 민감 정보 마스킹
   - 로그 접근 권한 제한
   - 로그 보관 기간 정책 수립

---

## 테스트 시나리오

### 단위 테스트
- [ ] 각 HTTP 상태 코드별 에러 핸들러 테스트
- [ ] 재시도 로직 테스트
- [ ] 로깅 함수 테스트

### 통합 테스트
- [ ] API 에러 발생 시 UI 반응 테스트
- [ ] 네트워크 오류 시뮬레이션
- [ ] 외부 서비스 장애 시뮬레이션

### E2E 테스트
- [ ] 401 에러 시 로그인 페이지 리다이렉트 확인
- [ ] 403 에러 시 에러 페이지 표시 확인
- [ ] 500 에러 시 재시도 버튼 동작 확인

---

## 참고 자료

### 내부 문서
- `/docs/userflow.md` - 15번 플로우
- `/docs/prd.md` - 비기능 요구사항 (보안, 가용성)
- `/docs/database.md` - RLS 정책

### 외부 자료
- [HTTP Status Codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)
- [React Error Boundaries](https://react.dev/reference/react/Component#catching-rendering-errors-with-an-error-boundary)
- [Axios Error Handling](https://axios-http.com/docs/handling_errors)
- [Sentry Documentation](https://docs.sentry.io/)

---

**문서 버전**: 1.0
**작성일**: 2025-12-12
**작성자**: Claude Code
**승인자**: [Product Owner 이름]
