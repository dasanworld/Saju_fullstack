This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: ./**/*.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.gemini/
  settings.json
public/
  easynext.png
src/
  app/
    (landing)/
      components/
        faq-section.tsx
        hero-section.tsx
        landing-header.tsx
        pricing-section.tsx
        service-section.tsx
      lib/
        constants.ts
    (protected)/
      analysis/
        [id]/
          page.tsx
      dashboard/
        page.tsx
      new-test/
        page.tsx
      subscription/
        fail/
          page.tsx
        success/
          page.tsx
        page.tsx
      layout.tsx
    api/
      [[...hono]]/
        route.ts
    example/
      page.tsx
    sign-in/
      [[...sign-in]]/
        page.tsx
    sign-up/
      [[...sign-up]]/
        page.tsx
    favicon.ico
    globals.css
    layout.tsx
    page.tsx
    providers.tsx
  backend/
    config/
      index.ts
    hono/
      app.ts
      context.ts
    http/
      response.ts
    middleware/
      context.ts
      error.ts
      supabase.ts
    supabase/
      client.ts
  components/
    layout/
      global-nav.tsx
      nav-footer.tsx
      protected-layout.tsx
    ui/
      accordion.tsx
      alert.tsx
      avatar.tsx
      badge.tsx
      button.tsx
      calendar.tsx
      card.tsx
      checkbox.tsx
      dialog.tsx
      dropdown-menu.tsx
      file-upload.tsx
      form.tsx
      input.tsx
      label.tsx
      popover.tsx
      radio-group.tsx
      select.tsx
      separator.tsx
      sheet.tsx
      skeleton.tsx
      textarea.tsx
      toast.tsx
      toaster.tsx
  constants/
    auth.ts
    env.ts
  features/
    auth/
      backend/
        error.ts
        helpers.ts
        route.ts
        schema.ts
        service.ts
      context/
        current-user-context.tsx
      hooks/
        useCurrentUser.ts
    cron/
      backend/
        error.ts
        route.ts
        service.ts
    example/
      backend/
        error.ts
        route.ts
        schema.ts
        service.ts
      components/
        example-status.tsx
      hooks/
        useExampleQuery.ts
      lib/
        dto.ts
    payments/
      backend/
        error.ts
        route.ts
        schema.ts
        service.ts
    subscription/
      backend/
        error.ts
        route.ts
        schema.ts
        service.ts
      components/
        cancel-confirm-modal.tsx
        current-subscription-card.tsx
        payment-dialog.tsx
        upgrade-prompt-card.tsx
      hooks/
        useCancelSubscription.ts
        useCreateSubscription.ts
        useReactivateSubscription.ts
        useSubscription.ts
      lib/
        dto.ts
    test/
      backend/
        error.ts
        route.ts
        schema.ts
        service.ts
      components/
        analysis-action-buttons.tsx
        analysis-result-section.tsx
        analysis-skeleton.tsx
        birth-date-picker.tsx
        birth-time-picker.tsx
        empty-test-state.tsx
        gender-selector.tsx
        new-test-form.tsx
        streaming-dialog.tsx
        test-card-list.tsx
        test-card.tsx
        test-info-card.tsx
        test-result-dialog.tsx
        test-search-bar.tsx
      hooks/
        useCreateTest.ts
        useDeleteTest.ts
        useInitTest.ts
        useStreamAnalysis.ts
        useTestDetail.ts
        useTestList.ts
      lib/
        dto.ts
  hooks/
    use-toast.ts
  lib/
    gemini/
      client.ts
      prompt.ts
      types.ts
    openai/
      client.ts
    remote/
      api-client.ts
    supabase/
      browser-client.ts
      client.ts
      server-client.ts
      server.ts
      types.ts
    toss/
      client.ts
      sdk.ts
      types.ts
    utils.ts
supabase/
  migrations/
    0001_create_example_table.sql
    0002_create_saju_tables.sql
    0003_add_payments_table.sql
    0004_setup_pg_cron_billing.sql
  scripts/
    setup_daily_billing_cron.sql
.cursorignore
.gitignore copy
components.json
eslint.config.mjs
middleware.ts
next.config.ts
package.json
postcss.config.mjs
ruler.toml
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gemini/settings.json">
{
  "contextFileName": "AGENTS.md"
}
</file>

<file path="src/app/(landing)/components/faq-section.tsx">
"use client";

import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "@/components/ui/accordion";
import { faqItems } from "../lib/constants";

export function FaqSection() {
  return (
    <section id="faq" className="bg-slate-50 py-16 md:py-24">
      <div className="container mx-auto px-4">
        <h2 className="text-3xl font-bold tracking-tight text-center text-slate-900 sm:text-4xl mb-4">
          자주 묻는 질문
        </h2>
        <p className="text-center text-slate-600 mb-12 max-w-2xl mx-auto">
          궁금하신 내용을 확인해보세요
        </p>

        <div className="max-w-3xl mx-auto">
          <Accordion type="single" collapsible className="w-full">
            {faqItems.map((item, index) => (
              <AccordionItem key={index} value={`item-${index}`}>
                <AccordionTrigger className="text-left">
                  {item.question}
                </AccordionTrigger>
                <AccordionContent className="text-slate-600">
                  {item.answer}
                </AccordionContent>
              </AccordionItem>
            ))}
          </Accordion>
        </div>
      </div>
    </section>
  );
}
</file>

<file path="src/app/(landing)/components/service-section.tsx">
"use client";

import { Sparkles, Tag, Archive } from "lucide-react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { serviceFeatures } from "../lib/constants";

const iconMap = {
  Sparkles: Sparkles,
  Tag: Tag,
  Archive: Archive,
};

export function ServiceSection() {
  return (
    <section
      id="service"
      className="bg-slate-50 py-16 md:py-24"
    >
      <div className="container mx-auto px-4">
        <h2 className="text-3xl font-bold tracking-tight text-center text-slate-900 sm:text-4xl mb-4">
          Saju피아가 특별한 이유
        </h2>
        <p className="text-center text-slate-600 mb-12 max-w-2xl mx-auto">
          AI 기반의 정확한 분석과 합리적인 가격으로 당신의 사주팔자를 확인하세요
        </p>

        <div className="grid gap-6 md:grid-cols-3 max-w-5xl mx-auto">
          {serviceFeatures.map((feature) => {
            const Icon =
              iconMap[feature.icon as keyof typeof iconMap] || Sparkles;
            return (
              <Card
                key={feature.title}
                className="border-slate-200 transition-shadow hover:shadow-lg"
              >
                <CardHeader>
                  <div className="mb-4 flex h-12 w-12 items-center justify-center rounded-lg bg-indigo-100">
                    <Icon className="h-6 w-6 text-indigo-600" />
                  </div>
                  <CardTitle className="text-xl">{feature.title}</CardTitle>
                </CardHeader>
                <CardContent>
                  <p className="text-slate-600">{feature.description}</p>
                </CardContent>
              </Card>
            );
          })}
        </div>
      </div>
    </section>
  );
}
</file>

<file path="src/app/(landing)/lib/constants.ts">
export const serviceFeatures = [
  {
    icon: "Sparkles",
    title: "AI 기반 정확한 분석",
    description:
      "Google Gemini 2.5 모델이 천간·지지·오행을 자동 계산하고 전문적인 사주팔자 해석을 제공합니다.",
  },
  {
    icon: "Tag",
    title: "합리적인 가격",
    description:
      "무료 3회 체험으로 부담 없이 시작하고, Pro는 월 3,900원의 저렴한 가격으로 월 10회 고품질 분석을 이용하실 수 있습니다.",
  },
  {
    icon: "Archive",
    title: "검사 내역 영구 보관",
    description:
      "과거 분석 내역을 언제든지 재확인할 수 있으며, 이름 기반 검색으로 빠르게 조회할 수 있습니다.",
  },
];

export const pricingPlans = {
  free: {
    name: "Free",
    price: 0,
    badge: "무료",
    features: [
      "가입 즉시 3회 무료 검사",
      "Gemini 2.5 Flash 모델 사용",
      "검사 내역 영구 보관",
      "마크다운 형식 분석 결과",
    ],
    cta: "시작하기",
  },
  pro: {
    name: "Pro",
    price: 3900,
    badge: "인기",
    features: [
      "월 10회 고품질 검사",
      "Gemini 2.5 Pro 모델 사용",
      "검사 내역 영구 보관",
      "마크다운 형식 분석 결과",
      "자동 결제 (결제일 기준 1개월)",
    ],
    cta: "Pro 시작하기",
  },
};

export const faqItems = [
  {
    question: "무료 체험은 어떻게 사용하나요?",
    answer:
      "Google 로그인 후 자동으로 3회 무료 검사 횟수가 제공됩니다. 별도의 신청 절차 없이 바로 사용하실 수 있습니다.",
  },
  {
    question: "Pro 구독은 어떻게 결제되나요?",
    answer:
      "토스페이먼츠 자동결제로 매월 3,900원이 청구됩니다. 빌링키 발급 후 매달 같은 날짜에 자동으로 결제됩니다.",
  },
  {
    question: "출생시간을 모르면 사주를 볼 수 없나요?",
    answer:
      "'출생시간 모름'을 체크하면 시간 정보 없이도 분석이 가능합니다. AI가 가능한 범위에서 분석을 제공합니다.",
  },
  {
    question: "구독을 취소하면 환불받을 수 있나요?",
    answer:
      "환불은 불가하지만 다음 결제일까지 서비스를 계속 이용할 수 있습니다. 결제일 이전에는 언제든지 취소를 철회할 수 있습니다.",
  },
  {
    question: "검사 결과는 어디에서 확인하나요?",
    answer:
      "대시보드에서 과거 검사 내역을 모두 확인할 수 있습니다. 이름으로 검색하거나 최신순으로 정렬하여 조회 가능합니다.",
  },
  {
    question: "Gemini Flash와 Pro 모델의 차이는 무엇인가요?",
    answer:
      "Pro 모델이 더 상세하고 심층적인 분석을 제공합니다. Flash 모델은 빠른 분석에 적합하며, Pro 모델은 더 정교한 해석을 원하시는 분께 추천합니다.",
  },
];
</file>

<file path="src/app/(protected)/new-test/page.tsx">
"use client";

import { NewTestForm } from "@/features/test/components/new-test-form";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";

export default function NewTestPage() {
  return (
    <div className="container max-w-2xl py-10">
      <Card>
        <CardHeader>
          <CardTitle className="text-2xl">새 사주 검사</CardTitle>
          <CardDescription>
            사주팔자 분석을 위한 정보를 입력해주세요
          </CardDescription>
        </CardHeader>
        <CardContent>
          <NewTestForm />
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/(protected)/subscription/fail/page.tsx">
"use client";

import { useSearchParams, useRouter } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { XCircle } from "lucide-react";

export default function PaymentFailPage() {
  const searchParams = useSearchParams();
  const router = useRouter();

  const errorCode = searchParams.get("code");
  const errorMessage = searchParams.get("message");

  const handleGoToSubscription = () => {
    router.push("/subscription");
  };

  const handleRetry = () => {
    router.push("/subscription");
  };

  return (
    <div className="container max-w-md mx-auto px-4 py-16">
      <Card>
        <CardHeader>
          <div className="flex justify-center mb-4">
            <XCircle className="h-16 w-16 text-red-500" />
          </div>
          <CardTitle className="text-center">결제 실패</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <Alert variant="destructive">
            <AlertDescription>
              {errorMessage || "결제 처리 중 문제가 발생했습니다."}
              {errorCode && (
                <span className="block mt-1 text-xs opacity-70">
                  오류 코드: {errorCode}
                </span>
              )}
            </AlertDescription>
          </Alert>

          <p className="text-sm text-gray-600 text-center">
            결제 정보를 확인하시고 다시 시도해주세요.
            <br />
            문제가 계속되면 고객센터로 문의해주세요.
          </p>

          <div className="space-y-2">
            <Button onClick={handleRetry} className="w-full">
              다시 시도하기
            </Button>
            <Button
              variant="outline"
              onClick={handleGoToSubscription}
              className="w-full"
            >
              구독 페이지로 돌아가기
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/(protected)/subscription/success/page.tsx">
"use client";

import { useEffect, useState } from "react";
import { useSearchParams, useRouter } from "next/navigation";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { CheckCircle, Loader2 } from "lucide-react";
import { useToast } from "@/hooks/use-toast";
import { apiClient } from "@/lib/remote/api-client";
import { useQueryClient } from "@tanstack/react-query";

export default function PaymentSuccessPage() {
  const searchParams = useSearchParams();
  const router = useRouter();
  const { toast } = useToast();
  const queryClient = useQueryClient();

  const [isProcessing, setIsProcessing] = useState(true);
  const [isSuccess, setIsSuccess] = useState(false);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);

  const paymentKey = searchParams.get("paymentKey");
  const orderId = searchParams.get("orderId");
  const amount = searchParams.get("amount");

  useEffect(() => {
    const confirmPayment = async () => {
      if (!paymentKey || !orderId || !amount) {
        setErrorMessage("결제 정보가 올바르지 않습니다.");
        setIsProcessing(false);
        return;
      }

      try {
        const response = await apiClient.post("/api/payments/confirm", {
          paymentKey,
          orderId,
          amount: Number(amount),
        });

        if (response.data.success) {
          setIsSuccess(true);
          await queryClient.invalidateQueries({ queryKey: ["subscription", "status"] });
          toast({
            title: "Pro 구독이 시작되었습니다!",
            description: "이제 월 10회 고품질 검사를 이용하실 수 있습니다.",
          });
        } else {
          setErrorMessage(response.data.error?.message || "결제 승인에 실패했습니다.");
        }
      } catch (error: any) {
        const message = error.response?.data?.error?.message || "결제 처리 중 오류가 발생했습니다.";
        setErrorMessage(message);
      } finally {
        setIsProcessing(false);
      }
    };

    confirmPayment();
  }, [paymentKey, orderId, amount, queryClient, toast]);

  const handleGoToSubscription = () => {
    router.push("/subscription");
  };

  if (isProcessing) {
    return (
      <div className="container max-w-md mx-auto px-4 py-16">
        <Card>
          <CardContent className="flex flex-col items-center justify-center py-12">
            <Loader2 className="h-12 w-12 animate-spin text-blue-500 mb-4" />
            <p className="text-lg font-medium">결제를 확인하고 있습니다...</p>
            <p className="text-sm text-gray-500 mt-2">잠시만 기다려주세요.</p>
          </CardContent>
        </Card>
      </div>
    );
  }

  if (errorMessage) {
    return (
      <div className="container max-w-md mx-auto px-4 py-16">
        <Card>
          <CardHeader>
            <CardTitle className="text-center text-red-600">결제 실패</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <Alert variant="destructive">
              <AlertDescription>{errorMessage}</AlertDescription>
            </Alert>
            <Button onClick={handleGoToSubscription} className="w-full">
              구독 페이지로 돌아가기
            </Button>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="container max-w-md mx-auto px-4 py-16">
      <Card>
        <CardContent className="flex flex-col items-center justify-center py-12">
          <CheckCircle className="h-16 w-16 text-green-500 mb-4" />
          <h2 className="text-2xl font-bold mb-2">결제 완료!</h2>
          <p className="text-gray-600 text-center mb-6">
            Pro 구독이 성공적으로 시작되었습니다.
            <br />
            이제 모든 프리미엄 기능을 이용하실 수 있습니다.
          </p>
          <div className="space-y-2 w-full">
            <Button onClick={handleGoToSubscription} className="w-full">
              구독 관리로 이동
            </Button>
            <Button
              variant="outline"
              onClick={() => router.push("/saju")}
              className="w-full"
            >
              사주 분석 시작하기
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/app/(protected)/subscription/page.tsx">
"use client";

import { useSubscription } from "@/features/subscription/hooks/useSubscription";
import { CurrentSubscriptionCard } from "@/features/subscription/components/current-subscription-card";
import { UpgradePromptCard } from "@/features/subscription/components/upgrade-prompt-card";
import { Skeleton } from "@/components/ui/skeleton";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";

export default function SubscriptionPage() {
  const { data: subscription, isLoading, isError, refetch } = useSubscription();

  if (isLoading) {
    return (
      <div className="container max-w-4xl mx-auto px-4 py-8">
        <h1 className="text-3xl font-bold tracking-tight">구독 관리</h1>
        <p className="mt-2 text-gray-600">
          현재 구독 상태를 확인하고 관리할 수 있습니다.
        </p>
        <div className="mt-8 space-y-4">
          <Skeleton className="h-64 w-full" />
          <Skeleton className="h-48 w-full" />
        </div>
      </div>
    );
  }

  if (isError || !subscription) {
    return (
      <div className="container max-w-4xl mx-auto px-4 py-8">
        <h1 className="text-3xl font-bold tracking-tight">구독 관리</h1>
        <Alert variant="destructive" className="mt-4">
          <AlertDescription>
            구독 정보를 불러올 수 없습니다. 다시 시도해주세요.
          </AlertDescription>
        </Alert>
        <Button onClick={() => refetch()} className="mt-4">
          다시 시도
        </Button>
      </div>
    );
  }

  const isFree = subscription.plan === "free";

  return (
    <div className="container max-w-4xl mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold tracking-tight">구독 관리</h1>
      <p className="mt-2 text-gray-600">
        현재 구독 상태를 확인하고 관리할 수 있습니다.
      </p>

      <div className="mt-8 space-y-6">
        <CurrentSubscriptionCard subscription={subscription} />
        {isFree && <UpgradePromptCard />}
      </div>
    </div>
  );
}
</file>

<file path="src/app/api/[[...hono]]/route.ts">
import { handle } from 'hono/vercel';
import { createHonoApp } from '@/backend/hono/app';

const app = createHonoApp();

export const GET = handle(app);
export const POST = handle(app);
export const PUT = handle(app);
export const PATCH = handle(app);
export const DELETE = handle(app);
export const OPTIONS = handle(app);

export const runtime = 'nodejs';
</file>

<file path="src/app/example/page.tsx">
'use client';

import { ExampleStatus } from '@/features/example/components/example-status';

export default function ExamplePage() {
  return (
    <div className="min-h-screen bg-gradient-to-b from-slate-950 via-slate-900 to-slate-950 px-6 py-16 text-slate-100">
      <ExampleStatus />
    </div>
  );
}
</file>

<file path="src/app/providers.tsx">
// In Next.js, this file would be called: app/providers.tsx
"use client";

// Since QueryClientProvider relies on useContext under the hood, we have to put 'use client' on top
import {
  isServer,
  QueryClient,
  QueryClientProvider,
} from "@tanstack/react-query";
import { ThemeProvider } from "next-themes";

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        // With SSR, we usually want to set some default staleTime
        // above 0 to avoid refetching immediately on the client
        staleTime: 60 * 1000,
      },
    },
  });
}

let browserQueryClient: QueryClient | undefined = undefined;

function getQueryClient() {
  if (isServer) {
    // Server: always make a new query client
    return makeQueryClient();
  } else {
    // Browser: make a new query client if we don't already have one
    // This is very important, so we don't re-make a new client if React
    // suspends during the initial render. This may not be needed if we
    // have a suspense boundary BELOW the creation of the query client
    if (!browserQueryClient) browserQueryClient = makeQueryClient();
    return browserQueryClient;
  }
}

export default function Providers({ children }: { children: React.ReactNode }) {
  // NOTE: Avoid useState when initializing the query client if you don't
  //       have a suspense boundary between this and the code that may
  //       suspend because React will throw away the client on the initial
  //       render if it suspends and there is no boundary
  const queryClient = getQueryClient();

  return (
    <ThemeProvider
      attribute="class"
      defaultTheme="system"
      enableSystem
      forcedTheme="light"
      disableTransitionOnChange
    >
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </ThemeProvider>
  );
}
</file>

<file path="src/backend/hono/context.ts">
import type { Context } from 'hono';
import type { SupabaseClient } from '@supabase/supabase-js';

export type AppLogger = Pick<Console, 'info' | 'error' | 'warn' | 'debug'>;

export type AppConfig = {
  supabase: {
    url: string;
    serviceRoleKey: string;
  };
};

export type AppVariables = {
  supabase: SupabaseClient;
  logger: AppLogger;
  config: AppConfig;
};

export type AppEnv = {
  Variables: AppVariables;
};

export type AppContext = Context<AppEnv>;

export const contextKeys = {
  supabase: 'supabase',
  logger: 'logger',
  config: 'config',
} as const satisfies Record<keyof AppVariables, keyof AppVariables>;

export const getSupabase = (c: AppContext) =>
  c.get(contextKeys.supabase) as SupabaseClient;

export const getLogger = (c: AppContext) =>
  c.get(contextKeys.logger) as AppLogger;

export const getConfig = (c: AppContext) =>
  c.get(contextKeys.config) as AppConfig;
</file>

<file path="src/backend/http/response.ts">
import type { ContentfulStatusCode } from 'hono/utils/http-status';
import type { AppContext } from '@/backend/hono/context';

export type SuccessResult<TData> = {
  ok: true;
  status: ContentfulStatusCode;
  data: TData;
};

export type ErrorResult<TCode extends string, TDetails = unknown> = {
  ok: false;
  status: ContentfulStatusCode;
  error: {
    code: TCode;
    message: string;
    details?: TDetails;
  };
};

export type HandlerResult<TData, TCode extends string, TDetails = unknown> =
  | SuccessResult<TData>
  | ErrorResult<TCode, TDetails>;

export const success = <TData>(
  data: TData,
  status: ContentfulStatusCode = 200,
): SuccessResult<TData> => ({
  ok: true,
  status,
  data,
});

export const failure = <TCode extends string, TDetails = unknown>(
  status: ContentfulStatusCode,
  code: TCode,
  message: string,
  details?: TDetails,
): ErrorResult<TCode, TDetails> => ({
  ok: false,
  status,
  error: {
    code,
    message,
    ...(details === undefined ? {} : { details }),
  },
});

export const respond = <TData, TCode extends string, TDetails = unknown>(
  c: AppContext,
  result: HandlerResult<TData, TCode, TDetails>,
) => {
  if (result.ok) {
    return c.json(result.data, result.status);
  }

  const errorResult = result as ErrorResult<TCode, TDetails>;

  return c.json(
    {
      error: errorResult.error,
    },
    errorResult.status,
  );
};
</file>

<file path="src/backend/middleware/context.ts">
import { createMiddleware } from 'hono/factory';
import { getAppConfig } from '@/backend/config';
import {
  contextKeys,
  type AppEnv,
  type AppLogger,
} from '@/backend/hono/context';

const logger: AppLogger = {
  info: (...args) => console.info(...args),
  error: (...args) => console.error(...args),
  warn: (...args) => console.warn(...args),
  debug: (...args) => console.debug(...args),
};

export const withAppContext = () => {
  const config = getAppConfig();

  return createMiddleware<AppEnv>(async (c, next) => {
    c.set(contextKeys.logger, logger);
    c.set(contextKeys.config, config);

    await next();
  });
};
</file>

<file path="src/backend/middleware/error.ts">
import { createMiddleware } from 'hono/factory';
import { match, P } from 'ts-pattern';
import {
  contextKeys,
  type AppEnv,
  type AppLogger,
} from '@/backend/hono/context';

export const errorBoundary = () =>
  createMiddleware<AppEnv>(async (c, next) => {
    try {
      await next();
    } catch (error) {
      const logger = c.get(contextKeys.logger) as AppLogger | undefined;
      const message = match(error)
        .with(P.instanceOf(Error), (err) => err.message)
        .otherwise(() => 'Unexpected error');

      logger?.error?.(error);

      return c.json(
        {
          error: {
            code: 'INTERNAL_SERVER_ERROR',
            message,
          },
        },
        500,
      );
    }
  });
</file>

<file path="src/backend/middleware/supabase.ts">
import { createMiddleware } from 'hono/factory';
import {
  contextKeys,
  type AppEnv,
} from '@/backend/hono/context';
import { createServiceClient } from '@/backend/supabase/client';

export const withSupabase = () =>
  createMiddleware<AppEnv>(async (c, next) => {
    const config = c.get(
      contextKeys.config,
    ) as AppEnv['Variables']['config'] | undefined;

    if (!config) {
      throw new Error('Application configuration is not available.');
    }

    const client = createServiceClient(config.supabase);

    c.set(contextKeys.supabase, client);

    await next();
  });
</file>

<file path="src/backend/supabase/client.ts">
import { createClient } from '@supabase/supabase-js';
import type { SupabaseClient } from '@supabase/supabase-js';

export type ServiceClientConfig = {
  url: string;
  serviceRoleKey: string;
};

export const createServiceClient = ({
  url,
  serviceRoleKey,
}: ServiceClientConfig): SupabaseClient =>
  createClient(url, serviceRoleKey, {
    auth: {
      persistSession: false,
    },
  });
</file>

<file path="src/components/layout/protected-layout.tsx">
"use client";

import { useCurrentUser } from "@/features/auth/hooks/useCurrentUser";
import { GlobalNav } from "./global-nav";
import { useRouter } from "next/navigation";
import { useEffect } from "react";
import { Loader2 } from "lucide-react";

type ProtectedLayoutProps = {
  children: React.ReactNode;
};

export function ProtectedLayout({ children }: ProtectedLayoutProps) {
  const { user, isLoading } = useCurrentUser();
  const router = useRouter();

  useEffect(() => {
    if (!isLoading && !user) {
      router.push("/sign-in");
    }
  }, [user, isLoading, router]);

  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <Loader2 className="w-8 h-8 animate-spin text-primary" />
      </div>
    );
  }

  if (!user) {
    return null;
  }

  return (
    <div className="flex">
      <GlobalNav />
      <main className="flex-1 ml-64 min-h-screen">{children}</main>
    </div>
  );
}
</file>

<file path="src/components/ui/accordion.tsx">
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
</file>

<file path="src/components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="src/components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="src/components/ui/badge.tsx">
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };
</file>

<file path="src/components/ui/calendar.tsx">
"use client"

import * as React from "react"
import {
  ChevronDownIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
} from "lucide-react"
import { DayButton, DayPicker, getDefaultClassNames } from "react-day-picker"

import { cn } from "@/lib/utils"
import { Button, buttonVariants } from "@/components/ui/button"

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  captionLayout = "label",
  buttonVariant = "ghost",
  formatters,
  components,
  ...props
}: React.ComponentProps<typeof DayPicker> & {
  buttonVariant?: React.ComponentProps<typeof Button>["variant"]
}) {
  const defaultClassNames = getDefaultClassNames()

  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn(
        "bg-background group/calendar p-3 [--cell-size:2rem] [[data-slot=card-content]_&]:bg-transparent [[data-slot=popover-content]_&]:bg-transparent",
        String.raw`rtl:**:[.rdp-button\_next>svg]:rotate-180`,
        String.raw`rtl:**:[.rdp-button\_previous>svg]:rotate-180`,
        className
      )}
      captionLayout={captionLayout}
      formatters={{
        formatMonthDropdown: (date) =>
          date.toLocaleString("default", { month: "short" }),
        ...formatters,
      }}
      classNames={{
        root: cn("w-fit", defaultClassNames.root),
        months: cn(
          "relative flex flex-col gap-4 md:flex-row",
          defaultClassNames.months
        ),
        month: cn("flex w-full flex-col gap-4", defaultClassNames.month),
        nav: cn(
          "absolute inset-x-0 top-0 flex w-full items-center justify-between gap-1",
          defaultClassNames.nav
        ),
        button_previous: cn(
          buttonVariants({ variant: buttonVariant }),
          "h-[--cell-size] w-[--cell-size] select-none p-0 aria-disabled:opacity-50",
          defaultClassNames.button_previous
        ),
        button_next: cn(
          buttonVariants({ variant: buttonVariant }),
          "h-[--cell-size] w-[--cell-size] select-none p-0 aria-disabled:opacity-50",
          defaultClassNames.button_next
        ),
        month_caption: cn(
          "flex h-[--cell-size] w-full items-center justify-center px-[--cell-size]",
          defaultClassNames.month_caption
        ),
        dropdowns: cn(
          "flex h-[--cell-size] w-full items-center justify-center gap-1.5 text-sm font-medium",
          defaultClassNames.dropdowns
        ),
        dropdown_root: cn(
          "has-focus:border-ring border-input shadow-xs has-focus:ring-ring/50 has-focus:ring-[3px] relative rounded-md border",
          defaultClassNames.dropdown_root
        ),
        dropdown: cn(
          "bg-popover absolute inset-0 opacity-0",
          defaultClassNames.dropdown
        ),
        caption_label: cn(
          "select-none font-medium",
          captionLayout === "label"
            ? "text-sm"
            : "[&>svg]:text-muted-foreground flex h-8 items-center gap-1 rounded-md pl-2 pr-1 text-sm [&>svg]:size-3.5",
          defaultClassNames.caption_label
        ),
        table: "w-full border-collapse",
        weekdays: cn("flex", defaultClassNames.weekdays),
        weekday: cn(
          "text-muted-foreground flex-1 select-none rounded-md text-[0.8rem] font-normal",
          defaultClassNames.weekday
        ),
        week: cn("mt-2 flex w-full", defaultClassNames.week),
        week_number_header: cn(
          "w-[--cell-size] select-none",
          defaultClassNames.week_number_header
        ),
        week_number: cn(
          "text-muted-foreground select-none text-[0.8rem]",
          defaultClassNames.week_number
        ),
        day: cn(
          "group/day relative aspect-square h-full w-full select-none p-0 text-center [&:first-child[data-selected=true]_button]:rounded-l-md [&:last-child[data-selected=true]_button]:rounded-r-md",
          defaultClassNames.day
        ),
        range_start: cn(
          "bg-accent rounded-l-md",
          defaultClassNames.range_start
        ),
        range_middle: cn("rounded-none", defaultClassNames.range_middle),
        range_end: cn("bg-accent rounded-r-md", defaultClassNames.range_end),
        today: cn(
          "bg-accent text-accent-foreground rounded-md data-[selected=true]:rounded-none",
          defaultClassNames.today
        ),
        outside: cn(
          "text-muted-foreground aria-selected:text-muted-foreground",
          defaultClassNames.outside
        ),
        disabled: cn(
          "text-muted-foreground opacity-50",
          defaultClassNames.disabled
        ),
        hidden: cn("invisible", defaultClassNames.hidden),
        ...classNames,
      }}
      components={{
        Root: ({ className, rootRef, ...props }) => {
          return (
            <div
              data-slot="calendar"
              ref={rootRef}
              className={cn(className)}
              {...props}
            />
          )
        },
        Chevron: ({ className, orientation, ...props }) => {
          if (orientation === "left") {
            return (
              <ChevronLeftIcon className={cn("size-4", className)} {...props} />
            )
          }

          if (orientation === "right") {
            return (
              <ChevronRightIcon
                className={cn("size-4", className)}
                {...props}
              />
            )
          }

          return (
            <ChevronDownIcon className={cn("size-4", className)} {...props} />
          )
        },
        DayButton: CalendarDayButton,
        WeekNumber: ({ children, ...props }) => {
          return (
            <td {...props}>
              <div className="flex size-[--cell-size] items-center justify-center text-center">
                {children}
              </div>
            </td>
          )
        },
        ...components,
      }}
      {...props}
    />
  )
}

function CalendarDayButton({
  className,
  day,
  modifiers,
  ...props
}: React.ComponentProps<typeof DayButton>) {
  const defaultClassNames = getDefaultClassNames()

  const ref = React.useRef<HTMLButtonElement>(null)
  React.useEffect(() => {
    if (modifiers.focused) ref.current?.focus()
  }, [modifiers.focused])

  return (
    <Button
      ref={ref}
      variant="ghost"
      size="icon"
      data-day={day.date.toLocaleDateString()}
      data-selected-single={
        modifiers.selected &&
        !modifiers.range_start &&
        !modifiers.range_end &&
        !modifiers.range_middle
      }
      data-range-start={modifiers.range_start}
      data-range-end={modifiers.range_end}
      data-range-middle={modifiers.range_middle}
      className={cn(
        "data-[selected-single=true]:bg-primary data-[selected-single=true]:text-primary-foreground data-[range-middle=true]:bg-accent data-[range-middle=true]:text-accent-foreground data-[range-start=true]:bg-primary data-[range-start=true]:text-primary-foreground data-[range-end=true]:bg-primary data-[range-end=true]:text-primary-foreground group-data-[focused=true]/day:border-ring group-data-[focused=true]/day:ring-ring/50 flex aspect-square h-auto w-full min-w-[--cell-size] flex-col gap-1 font-normal leading-none data-[range-end=true]:rounded-md data-[range-middle=true]:rounded-none data-[range-start=true]:rounded-md group-data-[focused=true]/day:relative group-data-[focused=true]/day:z-10 group-data-[focused=true]/day:ring-[3px] [&>span]:text-xs [&>span]:opacity-70",
        defaultClassNames.day,
        className
      )}
      {...props}
    />
  )
}

export { Calendar, CalendarDayButton }
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-xs",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="src/components/ui/checkbox.tsx">
"use client";

import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";

import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className,
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };
</file>

<file path="src/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
</file>

<file path="src/components/ui/dropdown-menu.tsx">
"use client";

import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-hidden focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-hidden transition-colors focus:bg-accent focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-hidden transition-colors focus:bg-accent focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-hidden transition-colors focus:bg-accent focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};
</file>

<file path="src/components/ui/file-upload.tsx">
"use client";

import { cn } from "@/lib/utils";
import { ChangeEvent, useRef } from "react";

interface FileUploadProps extends React.HTMLAttributes<HTMLDivElement> {
  onFileChange: (file: File) => void;
  accept?: string;
}

export function FileUpload({
  className,
  onFileChange,
  accept = "image/*",
  children,
  ...props
}: FileUploadProps) {
  const inputRef = useRef<HTMLInputElement>(null);

  const handleClick = () => {
    inputRef.current?.click();
  };

  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      onFileChange(file);
    }
  };

  return (
    <div
      onClick={handleClick}
      className={cn(
        "cursor-pointer rounded-md border-2 border-dashed border-gray-300 p-4 hover:border-gray-400",
        className
      )}
      {...props}
    >
      <input
        type="file"
        ref={inputRef}
        onChange={handleChange}
        accept={accept}
        className="hidden"
      />
      {children}
    </div>
  );
}
</file>

<file path="src/components/ui/form.tsx">
'use client';

import * as React from 'react';
import * as LabelPrimitive from '@radix-ui/react-label';
import { Slot } from '@radix-ui/react-slot';
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from 'react-hook-form';

import { cn } from '@/lib/utils';
import { Label } from '@/components/ui/label';

const Form = FormProvider;

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue,
);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();

  const fieldState = getFieldState(fieldContext.name, formState);

  if (!fieldContext) {
    throw new Error('useFormField should be used within <FormField>');
  }

  const { id } = itemContext;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue,
);

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId();

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn('space-y-2', className)} {...props} />
    </FormItemContext.Provider>
  );
});
FormItem.displayName = 'FormItem';

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField();

  return (
    <Label
      ref={ref}
      className={cn(error && 'text-destructive', className)}
      htmlFor={formItemId}
      {...props}
    />
  );
});
FormLabel.displayName = 'FormLabel';

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } =
    useFormField();

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  );
});
FormControl.displayName = 'FormControl';

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField();

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn('text-sm text-muted-foreground', className)}
      {...props}
    />
  );
});
FormDescription.displayName = 'FormDescription';

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error?.message) : children;

  if (!body) {
    return null;
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn('text-sm font-medium text-destructive', className)}
      {...props}
    >
      {body}
    </p>
  );
});
FormMessage.displayName = 'FormMessage';

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
};
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";

export { Input };
</file>

<file path="src/components/ui/label.tsx">
"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };
</file>

<file path="src/components/ui/popover.tsx">
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }
</file>

<file path="src/components/ui/radio-group.tsx">
"use client"

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }
</file>

<file path="src/components/ui/select.tsx">
'use client';

import * as React from 'react';
import * as SelectPrimitive from '@radix-ui/react-select';
import { Check, ChevronDown, ChevronUp } from 'lucide-react';

import { cn } from '@/lib/utils';

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      'flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1',
      className,
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      'flex cursor-default items-center justify-center py-1',
      className,
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      'flex cursor-default items-center justify-center py-1',
      className,
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = 'popper', ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        'relative z-50 max-h-96 min-w-32 overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        position === 'popper' &&
          'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',
        className,
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          'p-1',
          position === 'popper' &&
            'h-(--radix-select-trigger-height) w-full min-w-(--radix-select-trigger-width)',
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn('py-1.5 pl-8 pr-2 text-sm font-semibold', className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50',
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
};
</file>

<file path="src/components/ui/separator.tsx">
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-px w-full" : "h-full w-px",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
</file>

<file path="src/components/ui/sheet.tsx">
'use client';

import * as React from 'react';
import * as SheetPrimitive from '@radix-ui/react-dialog';
import { cva, type VariantProps } from 'class-variance-authority';
import { X } from 'lucide-react';

import { cn } from '@/lib/utils';

const Sheet = SheetPrimitive.Root;

const SheetTrigger = SheetPrimitive.Trigger;

const SheetClose = SheetPrimitive.Close;

const SheetPortal = SheetPrimitive.Portal;

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      'fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className,
    )}
    {...props}
    ref={ref}
  />
));
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName;

const sheetVariants = cva(
  'fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500',
  {
    variants: {
      side: {
        top: 'inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top',
        bottom:
          'inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom',
        left: 'inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm',
        right:
          'inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm',
      },
    },
    defaultVariants: {
      side: 'right',
    },
  },
);

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = 'right', className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
));
SheetContent.displayName = SheetPrimitive.Content.displayName;

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col space-y-2 text-center sm:text-left',
      className,
    )}
    {...props}
  />
);
SheetHeader.displayName = 'SheetHeader';

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2',
      className,
    )}
    {...props}
  />
);
SheetFooter.displayName = 'SheetFooter';

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn('text-lg font-semibold text-foreground', className)}
    {...props}
  />
));
SheetTitle.displayName = SheetPrimitive.Title.displayName;

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
SheetDescription.displayName = SheetPrimitive.Description.displayName;

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
};
</file>

<file path="src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from 'react';

import { cn } from '@/lib/utils';

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<'textarea'>
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        'flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm',
        className,
      )}
      ref={ref}
      {...props}
    />
  );
});
Textarea.displayName = 'Textarea';

export { Textarea };
</file>

<file path="src/components/ui/toast.tsx">
'use client';

import * as React from 'react';
import * as ToastPrimitives from '@radix-ui/react-toast';
import { cva, type VariantProps } from 'class-variance-authority';
import { X } from 'lucide-react';

import { cn } from '@/lib/utils';

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      'fixed top-0 z-100 flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]',
      className,
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  'group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-(--radix-toast-swipe-end-x) data-[swipe=move]:translate-x-(--radix-toast-swipe-move-x) data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full',
  {
    variants: {
      variant: {
        default: 'border bg-background text-foreground',
        destructive:
          'destructive group border-destructive bg-destructive text-destructive-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  },
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      'inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 hover:group-[.destructive]:border-destructive/30 hover:group-[.destructive]:bg-destructive hover:group-[.destructive]:text-destructive-foreground focus:group-[.destructive]:ring-destructive',
      className,
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      'absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-hidden focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 hover:group-[.destructive]:text-red-50 focus:group-[.destructive]:ring-red-400 focus:group-[.destructive]:ring-offset-red-600',
      className,
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn('text-sm font-semibold', className)}
    {...props}
  />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn('text-sm opacity-90', className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};
</file>

<file path="src/components/ui/toaster.tsx">
'use client';

import { useToast } from '@/hooks/use-toast';
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from '@/components/ui/toast';

export function Toaster() {
  const { toasts } = useToast();

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        );
      })}
      <ToastViewport />
    </ToastProvider>
  );
}
</file>

<file path="src/constants/env.ts">
import { z } from 'zod';

const clientEnvSchema = z.object({
  NEXT_PUBLIC_SUPABASE_URL: z.string().url(),
  NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string().min(1),
});

const _clientEnv = clientEnvSchema.safeParse({
  NEXT_PUBLIC_SUPABASE_URL: process.env.NEXT_PUBLIC_SUPABASE_URL,
  NEXT_PUBLIC_SUPABASE_ANON_KEY: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
});

export type ClientEnv = z.infer<typeof clientEnvSchema>;

if (!_clientEnv.success) {
  console.error('환경 변수 검증 실패:', _clientEnv.error.flatten().fieldErrors);
  throw new Error('환경 변수를 확인하세요.');
}

export const env: ClientEnv = _clientEnv.data;
</file>

<file path="src/features/auth/backend/error.ts">
export const authErrorCodes = {
  EMAIL_MISSING: "EMAIL_MISSING",
  USER_CREATE_FAILED: "USER_CREATE_FAILED",
  SUB_CREATE_FAILED: "SUB_CREATE_FAILED",
  USER_DELETE_FAILED: "USER_DELETE_FAILED",
  INTERNAL_ERROR: "INTERNAL_ERROR",
} as const;

export type AuthErrorCode =
  (typeof authErrorCodes)[keyof typeof authErrorCodes];
</file>

<file path="src/features/auth/backend/helpers.ts">
import { clerkClient } from "@clerk/nextjs/server";
import type { SupabaseClient } from "@supabase/supabase-js";
import type { AppLogger } from "@/backend/hono/context";

type DbUser = {
  id: string;
  email: string;
  clerk_user_id: string;
};

type GetOrCreateUserResult =
  | { success: true; user: DbUser; error?: never }
  | { success: false; user?: never; error: string };

export const getOrCreateUser = async (
  supabase: SupabaseClient,
  logger: AppLogger,
  clerkUserId: string
): Promise<GetOrCreateUserResult> => {
  const { data: existingUser } = await supabase
    .from("users")
    .select("id, email, clerk_user_id")
    .eq("clerk_user_id", clerkUserId)
    .single();

  if (existingUser) {
    return { success: true, user: existingUser };
  }

  try {
    const clerk = await clerkClient();
    const clerkUser = await clerk.users.getUser(clerkUserId);
    const email = clerkUser.emailAddresses[0]?.emailAddress;

    if (!email) {
      logger.error("Clerk user has no email", { clerkUserId });
      return { success: false, error: "이메일이 없습니다" };
    }

    const { data: newUser, error: insertError } = await supabase
      .from("users")
      .insert({
        clerk_user_id: clerkUserId,
        email,
      })
      .select("id, email, clerk_user_id")
      .single();

    if (insertError) {
      if (insertError.code === "23505") {
        const { data: raceUser } = await supabase
          .from("users")
          .select("id, email, clerk_user_id")
          .eq("clerk_user_id", clerkUserId)
          .single();

        if (raceUser) {
          return { success: true, user: raceUser };
        }
      }

      logger.error("User creation failed", insertError);
      return { success: false, error: "사용자 생성 실패" };
    }

    const { error: subError } = await supabase.from("subscriptions").insert({
      user_id: newUser.id,
      plan: "free",
      remaining_tests: 3,
    });

    if (subError) {
      logger.warn("Subscription creation failed", subError);
    }

    logger.info("User auto-created", { user_id: newUser.id, clerkUserId });

    return { success: true, user: newUser };
  } catch (error) {
    logger.error("Failed to fetch Clerk user", error);
    return { success: false, error: "사용자 정보를 가져올 수 없습니다" };
  }
};
</file>

<file path="src/features/cron/backend/error.ts">
export const cronErrorCodes = {
  UNAUTHORIZED: "UNAUTHORIZED",
  INTERNAL_ERROR: "INTERNAL_ERROR",
} as const;

export type CronErrorCode = (typeof cronErrorCodes)[keyof typeof cronErrorCodes];
</file>

<file path="src/features/cron/backend/route.ts">
import type { Hono } from "hono";
import type { AppEnv } from "@/backend/hono/context";
import { respond, failure } from "@/backend/http/response";
import { processDailyBilling } from "./service";
import { cronErrorCodes } from "./error";

export const registerCronRoutes = (app: Hono<AppEnv>) => {
  app.post("/api/cron/daily-billing", async (c) => {
    const authHeader = c.req.header("Authorization");
    const config = c.get("config");

    const cronSecret = process.env.CRON_SECRET;

    if (!authHeader || !cronSecret || authHeader !== `Bearer ${cronSecret}`) {
      return respond(
        c,
        failure(401, cronErrorCodes.UNAUTHORIZED, "인증 실패")
      );
    }

    return respond(c, await processDailyBilling(c));
  });
};
</file>

<file path="src/features/example/backend/error.ts">
export const exampleErrorCodes = {
  notFound: 'EXAMPLE_NOT_FOUND',
  fetchError: 'EXAMPLE_FETCH_ERROR',
  validationError: 'EXAMPLE_VALIDATION_ERROR',
} as const;

type ExampleErrorValue = (typeof exampleErrorCodes)[keyof typeof exampleErrorCodes];

export type ExampleServiceError = ExampleErrorValue;
</file>

<file path="src/features/example/backend/route.ts">
import type { Hono } from 'hono';
import {
  failure,
  respond,
  type ErrorResult,
} from '@/backend/http/response';
import {
  getLogger,
  getSupabase,
  type AppEnv,
} from '@/backend/hono/context';
import { ExampleParamsSchema } from '@/features/example/backend/schema';
import { getExampleById } from './service';
import {
  exampleErrorCodes,
  type ExampleServiceError,
} from './error';

export const registerExampleRoutes = (app: Hono<AppEnv>) => {
  app.get('/example/:id', async (c) => {
    const parsedParams = ExampleParamsSchema.safeParse({ id: c.req.param('id') });

    if (!parsedParams.success) {
      return respond(
        c,
        failure(
          400,
          'INVALID_EXAMPLE_PARAMS',
          'The provided example id is invalid.',
          parsedParams.error.format(),
        ),
      );
    }

    const supabase = getSupabase(c);
    const logger = getLogger(c);

    const result = await getExampleById(supabase, parsedParams.data.id);

    if (!result.ok) {
      const errorResult = result as ErrorResult<ExampleServiceError, unknown>;

      if (errorResult.error.code === exampleErrorCodes.fetchError) {
        logger.error('Failed to fetch example', errorResult.error.message);
      }

      return respond(c, result);
    }

    return respond(c, result);
  });
};
</file>

<file path="src/features/example/backend/schema.ts">
import { z } from 'zod';

export const ExampleParamsSchema = z.object({
  id: z.string().uuid({ message: 'Example id must be a valid UUID.' }),
});

export const ExampleResponseSchema = z.object({
  id: z.string().uuid(),
  fullName: z.string(),
  avatarUrl: z.string().url(),
  bio: z.string().nullable(),
  updatedAt: z.string(),
});

export type ExampleResponse = z.infer<typeof ExampleResponseSchema>;

export const ExampleTableRowSchema = z.object({
  id: z.string().uuid(),
  full_name: z.string().nullable(),
  avatar_url: z.string().nullable(),
  bio: z.string().nullable(),
  updated_at: z.string(),
});

export type ExampleRow = z.infer<typeof ExampleTableRowSchema>;
</file>

<file path="src/features/example/backend/service.ts">
import type { SupabaseClient } from '@supabase/supabase-js';
import {
  failure,
  success,
  type HandlerResult,
} from '@/backend/http/response';
import {
  ExampleResponseSchema,
  ExampleTableRowSchema,
  type ExampleResponse,
  type ExampleRow,
} from '@/features/example/backend/schema';
import {
  exampleErrorCodes,
  type ExampleServiceError,
} from '@/features/example/backend/error';

const EXAMPLE_TABLE = 'example';

const fallbackAvatar = (id: string) =>
  `https://picsum.photos/seed/${encodeURIComponent(id)}/200/200`;

export const getExampleById = async (
  client: SupabaseClient,
  id: string,
): Promise<HandlerResult<ExampleResponse, ExampleServiceError, unknown>> => {
  const { data, error } = await client
    .from(EXAMPLE_TABLE)
    .select('id, full_name, avatar_url, bio, updated_at')
    .eq('id', id)
    .maybeSingle<ExampleRow>();

  if (error) {
    return failure(500, exampleErrorCodes.fetchError, error.message);
  }

  if (!data) {
    return failure(404, exampleErrorCodes.notFound, 'Example not found');
  }

  const rowParse = ExampleTableRowSchema.safeParse(data);

  if (!rowParse.success) {
    return failure(
      500,
      exampleErrorCodes.validationError,
      'Example row failed validation.',
      rowParse.error.format(),
    );
  }

  const mapped = {
    id: rowParse.data.id,
    fullName: rowParse.data.full_name ?? 'Anonymous User',
    avatarUrl:
      rowParse.data.avatar_url ?? fallbackAvatar(rowParse.data.id),
    bio: rowParse.data.bio,
    updatedAt: rowParse.data.updated_at,
  } satisfies ExampleResponse;

  const parsed = ExampleResponseSchema.safeParse(mapped);

  if (!parsed.success) {
    return failure(
      500,
      exampleErrorCodes.validationError,
      'Example payload failed validation.',
      parsed.error.format(),
    );
  }

  return success(parsed.data);
};
</file>

<file path="src/features/example/components/example-status.tsx">
'use client';

import { useState } from 'react';
import type { FormEvent } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { useExampleQuery } from '@/features/example/hooks/useExampleQuery';

const statusBadge = (
  label: string,
  tone: 'success' | 'error' | 'idle',
) => {
  const toneStyles: Record<typeof tone, string> = {
    success: 'bg-emerald-500/10 text-emerald-300 border-emerald-400/40',
    error: 'bg-rose-500/10 text-rose-300 border-rose-400/40',
    idle: 'bg-slate-500/10 text-slate-200 border-slate-400/30',
  };

  return (
    <span
      className={`inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-medium ${toneStyles[tone]}`}
    >
      {label}
    </span>
  );
};

export const ExampleStatus = () => {
  const [inputValue, setInputValue] = useState('');
  const [exampleId, setExampleId] = useState('');
  const query = useExampleQuery(exampleId);

  const handleSubmit = (event: FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const trimmed = inputValue.trim();

    if (!trimmed) {
      setExampleId('');
      return;
    }

    if (trimmed === exampleId) {
      void query.refetch();
      return;
    }

    setExampleId(trimmed);
  };

  return (
    <section className="mx-auto flex w-full max-w-3xl flex-col gap-6">
      <header className="space-y-2 text-slate-100">
        <h1 className="text-3xl font-semibold tracking-tight">Backend Health Check</h1>
        <p className="text-sm text-slate-300">
          예시 API(`/api/example/:id`)가 정상 동작하는지 확인합니다. Supabase 예시
          레코드의 UUID를 입력하면 React Query를 통해 백엔드 응답을 확인할 수
          있습니다.
        </p>
      </header>

      <form
        onSubmit={handleSubmit}
        className="flex flex-col gap-3 rounded-xl border border-slate-800 bg-slate-950/60 p-4 md:flex-row md:items-center"
      >
        <div className="flex-1 space-y-1">
          <label className="text-xs uppercase tracking-wide text-slate-400">
            Example UUID
          </label>
          <Input
            value={inputValue}
            onChange={(event) => setInputValue(event.target.value)}
            placeholder="00000000-0000-0000-0000-000000000000"
            className="bg-slate-900/70 text-slate-100 placeholder:text-slate-600"
          />
        </div>
        <Button
          type="submit"
          variant="secondary"
          className="mt-2 h-12 rounded-lg border border-slate-600 bg-slate-800 text-slate-100 hover:bg-slate-700 md:mt-6"
        >
          조회하기
        </Button>
      </form>

      <article className="space-y-3 rounded-xl border border-slate-800 bg-slate-950/60 p-6 text-slate-100">
        <div className="flex items-center justify-between">
          <h2 className="text-lg font-semibold">현재 상태</h2>
          {exampleId
            ? query.status === 'pending'
              ? statusBadge('Fetching', 'idle')
              : query.status === 'error'
                ? statusBadge('Error', 'error')
                : statusBadge('Success', 'success')
            : statusBadge('Idle', 'idle')}
        </div>

        {!exampleId && (
          <p className="text-sm text-slate-300">
            UUID를 입력하고 조회하기 버튼을 누르면 결과가 이곳에 표시됩니다.
          </p>
        )}

        {exampleId && query.status === 'pending' && (
          <p className="text-sm text-slate-300">Supabase에서 데이터를 가져오는 중...</p>
        )}

        {query.status === 'error' && (
          <div className="space-y-2 rounded-lg border border-rose-400/30 bg-rose-500/5 p-4">
            <p className="text-sm font-medium text-rose-300">요청 실패</p>
            <p className="text-xs text-rose-200/80">
              {query.error instanceof Error
                ? query.error.message
                : '알 수 없는 에러가 발생했습니다.'}
            </p>
          </div>
        )}

        {query.data && (
          <div className="space-y-3 rounded-lg border border-emerald-400/30 bg-emerald-500/5 p-4 text-sm text-emerald-100">
            <div>
              <p className="text-xs uppercase tracking-wide text-emerald-300">ID</p>
              <p className="font-mono text-xs md:text-sm">{query.data.id}</p>
            </div>
            <div>
              <p className="text-xs uppercase tracking-wide text-emerald-300">
                이름
              </p>
              <p>{query.data.fullName}</p>
            </div>
            <div>
              <p className="text-xs uppercase tracking-wide text-emerald-300">
                소개
              </p>
              <p>{query.data.bio ?? '—'}</p>
            </div>
            <div>
              <p className="text-xs uppercase tracking-wide text-emerald-300">
                아바타
              </p>
              <a
                href={query.data.avatarUrl}
                target="_blank"
                rel="noreferrer"
                className="underline"
              >
                {query.data.avatarUrl}
              </a>
            </div>
            <div>
              <p className="text-xs uppercase tracking-wide text-emerald-300">
                업데이트 시각
              </p>
              <p>{query.data.updatedAt}</p>
            </div>
          </div>
        )}
      </article>
    </section>
  );
};
</file>

<file path="src/features/example/hooks/useExampleQuery.ts">
'use client';

import { useQuery } from '@tanstack/react-query';
import { apiClient, extractApiErrorMessage } from '@/lib/remote/api-client';
import { ExampleResponseSchema } from '@/features/example/lib/dto';

const fetchExample = async (id: string) => {
  try {
    const { data } = await apiClient.get(`/api/example/${id}`);
    return ExampleResponseSchema.parse(data);
  } catch (error) {
    const message = extractApiErrorMessage(error, 'Failed to fetch example.');
    throw new Error(message);
  }
};

export const useExampleQuery = (id: string) =>
  useQuery({
    queryKey: ['example', id],
    queryFn: () => fetchExample(id),
    enabled: Boolean(id),
    staleTime: 60 * 1000,
  });
</file>

<file path="src/features/example/lib/dto.ts">
export {
  ExampleParamsSchema,
  ExampleResponseSchema,
  type ExampleResponse,
} from '@/features/example/backend/schema';
</file>

<file path="src/features/payments/backend/error.ts">
export const paymentsErrorCodes = {
  PAYMENT_CONFIRMATION_FAILED: "PAYMENT_CONFIRMATION_FAILED",
  AMOUNT_MISMATCH: "AMOUNT_MISMATCH",
  INVALID_ORDER: "INVALID_ORDER",
  TOSS_API_ERROR: "TOSS_API_ERROR",
  INTERNAL_ERROR: "INTERNAL_ERROR",
} as const;

export type PaymentsErrorCode =
  (typeof paymentsErrorCodes)[keyof typeof paymentsErrorCodes];
</file>

<file path="src/features/payments/backend/route.ts">
import type { Hono } from "hono";
import { zValidator } from "@hono/zod-validator";
import { getAuth } from "@hono/clerk-auth";
import type { AppEnv } from "@/backend/hono/context";
import { respond, failure } from "@/backend/http/response";
import { confirmPaymentRequestSchema } from "./schema";
import { confirmPayment } from "./service";
import { paymentsErrorCodes } from "./error";
import { getOrCreateUser } from "@/features/auth/backend/helpers";

export const registerPaymentsRoutes = (app: Hono<AppEnv>) => {
  app.post(
    "/api/payments/confirm",
    zValidator("json", confirmPaymentRequestSchema) as never,
    async (c) => {
      const auth = getAuth(c);

      if (!auth?.userId) {
        return respond(
          c,
          failure(401, paymentsErrorCodes.INTERNAL_ERROR, "인증이 필요합니다")
        );
      }

      const supabase = c.get("supabase");
      const logger = c.get("logger");
      const userResult = await getOrCreateUser(supabase, logger, auth.userId);

      if (!userResult.success) {
        return respond(
          c,
          failure(404, paymentsErrorCodes.INTERNAL_ERROR, userResult.error)
        );
      }

      const body = await c.req.json();
      const parsed = confirmPaymentRequestSchema.parse(body);

      return respond(
        c,
        await confirmPayment(
          supabase,
          userResult.user.id,
          parsed.paymentKey,
          parsed.orderId,
          parsed.amount
        )
      );
    }
  );
};
</file>

<file path="src/features/payments/backend/schema.ts">
import { z } from "zod";

export const confirmPaymentRequestSchema = z.object({
  paymentKey: z.string().min(1, "paymentKey is required"),
  orderId: z.string().min(1, "orderId is required"),
  amount: z.number().positive("amount must be positive"),
});

export type ConfirmPaymentRequest = z.infer<typeof confirmPaymentRequestSchema>;

export const confirmPaymentResponseSchema = z.object({
  success: z.boolean(),
  paymentKey: z.string().optional(),
  orderId: z.string().optional(),
  status: z.string().optional(),
});

export type ConfirmPaymentResponse = z.infer<typeof confirmPaymentResponseSchema>;
</file>

<file path="src/features/subscription/backend/error.ts">
export const subscriptionErrorCodes = {
  SUBSCRIPTION_NOT_FOUND: "SUBSCRIPTION_NOT_FOUND",
  ALREADY_PRO: "ALREADY_PRO",
  PAYMENT_FAILED: "PAYMENT_FAILED",
  NOT_PRO: "NOT_PRO",
  ALREADY_CANCELLED: "ALREADY_CANCELLED",
  NOT_CANCELLED: "NOT_CANCELLED",
  PERIOD_EXPIRED: "PERIOD_EXPIRED",
  INTERNAL_ERROR: "INTERNAL_ERROR",
} as const;

export type SubscriptionErrorCode =
  (typeof subscriptionErrorCodes)[keyof typeof subscriptionErrorCodes];
</file>

<file path="src/features/subscription/backend/schema.ts">
import { z } from "zod";

export const createSubscriptionRequestSchema = z.object({
  billing_key: z.string().min(1),
});

export const subscriptionStatusResponseSchema = z.object({
  plan: z.enum(["free", "pro"]),
  remaining_tests: z.number(),
  billing_key: z.string().nullable(),
  next_billing_date: z.string().nullable(),
  cancel_at_period_end: z.boolean(),
});

export const createSubscriptionResponseSchema = z.object({
  message: z.string(),
});

export const cancelSubscriptionResponseSchema = z.object({
  message: z.string(),
});

export const reactivateSubscriptionResponseSchema = z.object({
  message: z.string(),
});

export type CreateSubscriptionRequest = z.infer<
  typeof createSubscriptionRequestSchema
>;
export type SubscriptionStatusResponse = z.infer<
  typeof subscriptionStatusResponseSchema
>;
export type CreateSubscriptionResponse = z.infer<
  typeof createSubscriptionResponseSchema
>;
export type CancelSubscriptionResponse = z.infer<
  typeof cancelSubscriptionResponseSchema
>;
export type ReactivateSubscriptionResponse = z.infer<
  typeof reactivateSubscriptionResponseSchema
>;
</file>

<file path="src/features/subscription/backend/service.ts">
import type { AppContext } from "@/backend/hono/context";
import { success, failure } from "@/backend/http/response";
import { chargeTossPayment, deleteTossBillingKey } from "@/lib/toss/client";
import type {
  CreateSubscriptionRequest,
  CreateSubscriptionResponse,
  SubscriptionStatusResponse,
  CancelSubscriptionResponse,
  ReactivateSubscriptionResponse,
} from "./schema";
import { subscriptionErrorCodes } from "./error";
import type { SupabaseClient } from "@supabase/supabase-js";

const PRO_PRICE = 3900;

export const getSubscriptionStatus = async (
  supabase: SupabaseClient,
  userId: string
) => {
  try {
    const { data, error } = await supabase
      .from("subscriptions")
      .select("plan, remaining_tests, billing_key, next_billing_date, cancel_at_period_end")
      .eq("user_id", userId)
      .single();

    if (error || !data) {
      return failure(
        404,
        subscriptionErrorCodes.SUBSCRIPTION_NOT_FOUND,
        "구독 정보를 찾을 수 없습니다"
      );
    }

    const response: SubscriptionStatusResponse = {
      plan: data.plan,
      remaining_tests: data.remaining_tests,
      billing_key: data.billing_key,
      next_billing_date: data.next_billing_date,
      cancel_at_period_end: data.cancel_at_period_end,
    };

    return success(response);
  } catch (error) {
    return failure(500, subscriptionErrorCodes.INTERNAL_ERROR, "서버 오류");
  }
};

export const createProSubscription = async (
  c: AppContext,
  userId: string,
  userEmail: string,
  input: CreateSubscriptionRequest
) => {
  const supabase = c.get("supabase");
  const logger = c.get("logger");

  try {
    const { data: subscription, error: subError } = await supabase
      .from("subscriptions")
      .select("plan")
      .eq("user_id", userId)
      .single();

    if (subError || !subscription) {
      return failure(
        404,
        subscriptionErrorCodes.SUBSCRIPTION_NOT_FOUND,
        "구독 정보를 찾을 수 없습니다"
      );
    }

    if (subscription.plan === "pro") {
      return failure(
        409,
        subscriptionErrorCodes.ALREADY_PRO,
        "이미 Pro 구독 중입니다"
      );
    }

    const paymentResult = await chargeTossPayment({
      billing_key: input.billing_key,
      amount: PRO_PRICE,
      customer_email: userEmail,
    });

    if (!paymentResult.success) {
      logger.error("Payment failed", paymentResult.error);
      return failure(
        500,
        subscriptionErrorCodes.PAYMENT_FAILED,
        paymentResult.error || "결제 실패"
      );
    }

    const nextBillingDate = new Date();
    nextBillingDate.setMonth(nextBillingDate.getMonth() + 1);

    const { error: updateError } = await supabase
      .from("subscriptions")
      .update({
        plan: "pro",
        billing_key: input.billing_key,
        next_billing_date: nextBillingDate.toISOString().split("T")[0],
        remaining_tests: 10,
        cancel_at_period_end: false,
      })
      .eq("user_id", userId);

    if (updateError) {
      logger.error("Subscription update failed", updateError);
      return failure(
        500,
        subscriptionErrorCodes.INTERNAL_ERROR,
        "구독 업데이트 실패"
      );
    }

    logger.info("Pro subscription created", { user_id: userId });

    const response: CreateSubscriptionResponse = {
      message: "Pro 구독이 시작되었습니다",
    };

    return success(response);
  } catch (error) {
    logger.error("Unexpected error", error);
    return failure(500, subscriptionErrorCodes.INTERNAL_ERROR, "서버 오류");
  }
};

export const cancelSubscription = async (
  supabase: SupabaseClient,
  userId: string
) => {
  try {
    const { data: subscription, error: subError } = await supabase
      .from("subscriptions")
      .select("plan, cancel_at_period_end")
      .eq("user_id", userId)
      .single();

    if (subError || !subscription) {
      return failure(
        404,
        subscriptionErrorCodes.SUBSCRIPTION_NOT_FOUND,
        "구독 정보를 찾을 수 없습니다"
      );
    }

    if (subscription.plan !== "pro") {
      return failure(
        400,
        subscriptionErrorCodes.NOT_PRO,
        "Pro 구독이 아닙니다"
      );
    }

    if (subscription.cancel_at_period_end) {
      return failure(
        409,
        subscriptionErrorCodes.ALREADY_CANCELLED,
        "이미 취소 예약되었습니다"
      );
    }

    const { error: updateError } = await supabase
      .from("subscriptions")
      .update({ cancel_at_period_end: true })
      .eq("user_id", userId);

    if (updateError) {
      return failure(
        500,
        subscriptionErrorCodes.INTERNAL_ERROR,
        "구독 취소 실패"
      );
    }

    const response: CancelSubscriptionResponse = {
      message: "구독 취소가 예약되었습니다",
    };

    return success(response);
  } catch (error) {
    return failure(500, subscriptionErrorCodes.INTERNAL_ERROR, "서버 오류");
  }
};

export const reactivateSubscription = async (
  supabase: SupabaseClient,
  userId: string
) => {
  try {
    const { data: subscription, error: subError } = await supabase
      .from("subscriptions")
      .select("plan, cancel_at_period_end, next_billing_date")
      .eq("user_id", userId)
      .single();

    if (subError || !subscription) {
      return failure(
        404,
        subscriptionErrorCodes.SUBSCRIPTION_NOT_FOUND,
        "구독 정보를 찾을 수 없습니다"
      );
    }

    if (!subscription.cancel_at_period_end) {
      return failure(
        400,
        subscriptionErrorCodes.NOT_CANCELLED,
        "취소 예약 상태가 아닙니다"
      );
    }

    if (
      subscription.next_billing_date &&
      new Date(subscription.next_billing_date) <= new Date()
    ) {
      return failure(
        400,
        subscriptionErrorCodes.PERIOD_EXPIRED,
        "구독 기간이 만료되어 철회할 수 없습니다"
      );
    }

    const { error: updateError } = await supabase
      .from("subscriptions")
      .update({ cancel_at_period_end: false })
      .eq("user_id", userId);

    if (updateError) {
      return failure(
        500,
        subscriptionErrorCodes.INTERNAL_ERROR,
        "철회 실패"
      );
    }

    const response: ReactivateSubscriptionResponse = {
      message: "구독 취소가 철회되었습니다",
    };

    return success(response);
  } catch (error) {
    return failure(500, subscriptionErrorCodes.INTERNAL_ERROR, "서버 오류");
  }
};
</file>

<file path="src/features/subscription/components/cancel-confirm-modal.tsx">
"use client";

import { useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { useCancelSubscription } from "../hooks/useCancelSubscription";
import { useSubscription } from "../hooks/useSubscription";
import { useQueryClient } from "@tanstack/react-query";
import { useToast } from "@/hooks/use-toast";
import { format, parseISO } from "date-fns";

interface CancelConfirmModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export function CancelConfirmModal({ isOpen, onClose }: CancelConfirmModalProps) {
  const [isCancelling, setIsCancelling] = useState(false);
  const { data: subscription } = useSubscription();
  const cancelSubscription = useCancelSubscription();
  const queryClient = useQueryClient();
  const { toast } = useToast();

  const handleConfirmCancel = async () => {
    setIsCancelling(true);
    try {
      await cancelSubscription.mutateAsync();
      await queryClient.invalidateQueries({ queryKey: ["subscription", "status"] });

      toast({
        title: "구독 취소가 예약되었습니다",
        description: "다음 결제일까지 서비스를 계속 이용하실 수 있습니다.",
      });
      onClose();
    } catch (error) {
      toast({
        title: "구독 취소에 실패했습니다",
        description: "다시 시도해주세요.",
        variant: "destructive",
      });
    } finally {
      setIsCancelling(false);
    }
  };

  const nextBillingDate = subscription?.next_billing_date
    ? format(parseISO(subscription.next_billing_date), "yyyy년 MM월 dd일")
    : "";

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>구독을 취소하시겠습니까?</DialogTitle>
          <DialogDescription>
            다음 사항을 확인해주세요.
          </DialogDescription>
        </DialogHeader>

        <Alert>
          <AlertDescription className="space-y-2">
            <p>• 다음 결제일({nextBillingDate})까지 서비스를 계속 이용하실 수 있습니다.</p>
            <p>• 결제일 이전에는 언제든지 취소를 철회할 수 있습니다.</p>
            <p>• 환불은 불가합니다.</p>
          </AlertDescription>
        </Alert>

        <DialogFooter>
          <Button variant="outline" onClick={onClose} disabled={isCancelling}>
            돌아가기
          </Button>
          <Button
            variant="destructive"
            onClick={handleConfirmCancel}
            disabled={isCancelling}
          >
            {isCancelling ? "처리 중..." : "취소하기"}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/features/subscription/components/current-subscription-card.tsx">
"use client";

import { useState } from "react";
import { Card, CardHeader, CardTitle, CardContent, CardFooter } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { format, parseISO } from "date-fns";
import { useToast } from "@/hooks/use-toast";
import { useCancelSubscription } from "../hooks/useCancelSubscription";
import { useReactivateSubscription } from "../hooks/useReactivateSubscription";
import { useQueryClient } from "@tanstack/react-query";
import { CancelConfirmModal } from "./cancel-confirm-modal";
import type { SubscriptionStatusResponse } from "../lib/dto";

interface CurrentSubscriptionCardProps {
  subscription: SubscriptionStatusResponse;
}

export function CurrentSubscriptionCard({ subscription }: CurrentSubscriptionCardProps) {
  const [isCancelModalOpen, setIsCancelModalOpen] = useState(false);
  const [isReactivating, setIsReactivating] = useState(false);
  const { toast } = useToast();
  const reactivateSubscription = useReactivateSubscription();
  const queryClient = useQueryClient();

  const isFree = subscription.plan === "free";
  const isPro = subscription.plan === "pro";
  const isCancelScheduled = subscription.cancel_at_period_end;

  const maxTests = isPro ? 10 : 3;
  const modelName = isPro ? "Gemini 2.5 Pro" : "Gemini 2.5 Flash";

  const handleReactivate = async () => {
    setIsReactivating(true);
    try {
      await reactivateSubscription.mutateAsync();
      await queryClient.invalidateQueries({ queryKey: ["subscription", "status"] });

      toast({
        title: "구독 취소가 철회되었습니다",
        description: "다음 결제일에 정상적으로 자동 갱신됩니다.",
      });
    } catch (error) {
      toast({
        title: "철회에 실패했습니다",
        description: "다시 시도해주세요.",
        variant: "destructive",
      });
    } finally {
      setIsReactivating(false);
    }
  };

  if (isFree) {
    return (
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            Free 플랜
            <Badge variant="outline">무료</Badge>
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <div>
            <p className="text-sm text-muted-foreground">잔여 횟수</p>
            <p className="text-2xl font-bold">
              {subscription.remaining_tests}/{maxTests}
            </p>
          </div>
          <div>
            <p className="text-sm text-muted-foreground">사용 모델</p>
            <p className="font-medium">{modelName}</p>
          </div>
          <div className="border-t pt-4">
            <p className="text-sm font-semibold">혜택</p>
            <ul className="mt-2 space-y-1 text-sm text-muted-foreground">
              <li>✓ 가입 즉시 3회 무료 검사</li>
              <li>✓ Gemini 2.5 Flash 모델 사용</li>
              <li>✓ 검사 내역 영구 보관</li>
              <li>✓ 마크다운 형식 분석 결과</li>
            </ul>
          </div>
        </CardContent>
      </Card>
    );
  }

  if (isPro && !isCancelScheduled) {
    return (
      <>
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              Pro 플랜
              <Badge variant="default">활성</Badge>
            </CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div>
              <p className="text-sm text-muted-foreground">잔여 횟수</p>
              <p className="text-2xl font-bold">
                {subscription.remaining_tests}/{maxTests}
              </p>
            </div>
            <div>
              <p className="text-sm text-muted-foreground">다음 결제일</p>
              <p className="font-medium">
                {subscription.next_billing_date
                  ? format(parseISO(subscription.next_billing_date), "yyyy년 MM월 dd일")
                  : "-"}
              </p>
            </div>
            <div>
              <p className="text-sm text-muted-foreground">사용 모델</p>
              <p className="font-medium">{modelName}</p>
            </div>
            <div>
              <p className="text-sm text-muted-foreground">결제 정보</p>
              <p className="font-medium">월 3,900원 자동 결제</p>
            </div>
          </CardContent>
          <CardFooter>
            <Button
              variant="destructive"
              onClick={() => setIsCancelModalOpen(true)}
              className="w-full"
            >
              구독 취소
            </Button>
          </CardFooter>
        </Card>
        <CancelConfirmModal
          isOpen={isCancelModalOpen}
          onClose={() => setIsCancelModalOpen(false)}
        />
      </>
    );
  }

  if (isPro && isCancelScheduled) {
    return (
      <Card className="border-orange-200">
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            Pro 플랜
            <Badge variant="destructive">취소 예정</Badge>
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <Alert variant="destructive">
            <AlertDescription>
              ⚠️ {subscription.next_billing_date
                ? format(parseISO(subscription.next_billing_date), "yyyy년 MM월 dd일")
                : "다음 결제일"}에 구독이 종료됩니다
            </AlertDescription>
          </Alert>

          <div>
            <p className="text-sm text-muted-foreground">
              잔여 횟수 (종료일까지 사용 가능)
            </p>
            <p className="text-2xl font-bold">
              {subscription.remaining_tests}/{maxTests}
            </p>
          </div>
          <div>
            <p className="text-sm text-muted-foreground">사용 모델</p>
            <p className="font-medium">{modelName}</p>
          </div>
          <div>
            <p className="text-sm text-muted-foreground">안내</p>
            <ul className="mt-1 space-y-1 text-sm text-muted-foreground">
              <li>• 종료일까지 Pro 서비스를 계속 이용하실 수 있습니다</li>
              <li>• 다음 결제가 진행되지 않습니다</li>
              <li>• 종료 후 Free 플랜으로 전환됩니다</li>
            </ul>
          </div>
        </CardContent>
        <CardFooter>
          <Button
            onClick={handleReactivate}
            disabled={isReactivating}
            className="w-full"
          >
            {isReactivating ? "처리 중..." : "취소 철회"}
          </Button>
        </CardFooter>
      </Card>
    );
  }

  return null;
}
</file>

<file path="src/features/subscription/hooks/useCancelSubscription.ts">
"use client";

import { useMutation, useQueryClient } from "@tanstack/react-query";
import { apiClient } from "@/lib/remote/api-client";
import type { CancelSubscriptionResponse } from "../lib/dto";

export const useCancelSubscription = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async () => {
      const response = await apiClient.post<CancelSubscriptionResponse>(
        "/api/subscription/cancel"
      );
      return response.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["subscription", "status"] });
    },
  });
};
</file>

<file path="src/features/subscription/hooks/useCreateSubscription.ts">
"use client";

import { useMutation, useQueryClient } from "@tanstack/react-query";
import { apiClient } from "@/lib/remote/api-client";
import type {
  CreateSubscriptionRequest,
  CreateSubscriptionResponse,
} from "../lib/dto";

export const useCreateSubscription = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data: CreateSubscriptionRequest) => {
      const response = await apiClient.post<CreateSubscriptionResponse>(
        "/api/subscription/create",
        data
      );
      return response.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["subscription", "status"] });
    },
  });
};
</file>

<file path="src/features/subscription/hooks/useReactivateSubscription.ts">
"use client";

import { useMutation, useQueryClient } from "@tanstack/react-query";
import { apiClient } from "@/lib/remote/api-client";
import type { ReactivateSubscriptionResponse } from "../lib/dto";

export const useReactivateSubscription = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async () => {
      const response = await apiClient.post<ReactivateSubscriptionResponse>(
        "/api/subscription/reactivate"
      );
      return response.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["subscription", "status"] });
    },
  });
};
</file>

<file path="src/features/subscription/hooks/useSubscription.ts">
"use client";

import { useQuery } from "@tanstack/react-query";
import { apiClient } from "@/lib/remote/api-client";
import type { SubscriptionStatusResponse } from "../lib/dto";

export const useSubscription = () => {
  return useQuery({
    queryKey: ["subscription", "status"],
    queryFn: async () => {
      const response = await apiClient.get<SubscriptionStatusResponse>(
        "/api/subscription/status"
      );
      return response.data;
    },
  });
};
</file>

<file path="src/features/subscription/lib/dto.ts">
export {
  createSubscriptionRequestSchema,
  subscriptionStatusResponseSchema,
  createSubscriptionResponseSchema,
  cancelSubscriptionResponseSchema,
  reactivateSubscriptionResponseSchema,
  type CreateSubscriptionRequest,
  type SubscriptionStatusResponse,
  type CreateSubscriptionResponse,
  type CancelSubscriptionResponse,
  type ReactivateSubscriptionResponse,
} from "../backend/schema";
</file>

<file path="src/features/test/components/analysis-action-buttons.tsx">
"use client";

import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { ArrowLeft, Plus } from "lucide-react";

export function AnalysisActionButtons() {
  const router = useRouter();

  return (
    <div className="flex gap-3 justify-center">
      <Button
        variant="outline"
        onClick={() => router.push("/dashboard")}
        className="gap-2"
      >
        <ArrowLeft className="w-4 h-4" aria-hidden="true" />
        대시보드로 돌아가기
      </Button>

      <Button onClick={() => router.push("/new-test")} className="gap-2">
        <Plus className="w-4 h-4" aria-hidden="true" />
        새 검사 시작
      </Button>
    </div>
  );
}
</file>

<file path="src/features/test/components/analysis-result-section.tsx">
"use client";

import { useState } from "react";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import { Card, CardContent } from "@/components/ui/card";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { AlertCircle } from "lucide-react";

interface Props {
  result: string;
}

export function AnalysisResultSection({ result }: Props) {
  const [hasError, setHasError] = useState(false);

  if (!result) {
    return (
      <Alert className="mb-6">
        <AlertCircle className="h-4 w-4" />
        <AlertTitle>분석 결과 없음</AlertTitle>
        <AlertDescription>
          분석 결과가 아직 준비되지 않았습니다. 잠시 후 다시 확인해주세요.
        </AlertDescription>
      </Alert>
    );
  }

  if (hasError) {
    return (
      <Card className="mb-6">
        <CardContent className="pt-6">
          <Alert variant="destructive" className="mb-4">
            <AlertCircle className="h-4 w-4" />
            <AlertTitle>형식 변환 오류</AlertTitle>
            <AlertDescription>
              형식 변환 중 오류가 발생했습니다. 원본 텍스트를 표시합니다.
            </AlertDescription>
          </Alert>
          <pre className="whitespace-pre-wrap text-sm font-mono bg-gray-50 p-4 rounded-lg">
            {result}
          </pre>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="mb-6" role="article" aria-label="사주팔자 분석 결과">
      <CardContent className="pt-6">
        <div className="prose prose-amber max-w-none">
          <ReactMarkdown
            remarkPlugins={[remarkGfm]}
            components={{
              h1: ({ node, ...props }) => (
                <h1
                  className="text-3xl font-bold text-amber-900 mt-8 mb-4"
                  {...props}
                />
              ),
              h2: ({ node, ...props }) => (
                <h2
                  className="text-2xl font-bold text-amber-900 mt-6 mb-3"
                  {...props}
                />
              ),
              h3: ({ node, ...props }) => (
                <h3
                  className="text-xl font-semibold text-amber-800 mt-4 mb-2"
                  {...props}
                />
              ),
              p: ({ node, ...props }) => (
                <p className="text-gray-700 mb-4 leading-relaxed" {...props} />
              ),
              ul: ({ node, ...props }) => (
                <ul
                  className="list-disc ml-6 text-gray-700 space-y-1 mb-4"
                  {...props}
                />
              ),
              ol: ({ node, ...props }) => (
                <ol
                  className="list-decimal ml-6 text-gray-700 space-y-1 mb-4"
                  {...props}
                />
              ),
              li: ({ node, ...props }) => (
                <li className="text-gray-700" {...props} />
              ),
              blockquote: ({ node, ...props }) => (
                <blockquote
                  className="border-l-4 border-amber-500 pl-4 italic text-gray-600 my-4 bg-amber-50 py-2"
                  {...props}
                />
              ),
              code: ({ node, inline, ...props }: { node?: any; inline?: boolean }) => {
                return inline ? (
                  <code
                    className="bg-amber-100 text-amber-900 px-1.5 py-0.5 rounded text-sm font-mono"
                    {...props}
                  />
                ) : (
                  <code
                    className="block bg-gray-900 text-gray-100 p-4 rounded-lg overflow-x-auto text-sm font-mono"
                    {...props}
                  />
                );
              },
              pre: ({ node, ...props }) => (
                <pre className="mb-4 overflow-x-auto" {...props} />
              ),
              strong: ({ node, ...props }) => (
                <strong className="font-bold text-amber-900" {...props} />
              ),
              em: ({ node, ...props }) => (
                <em className="italic text-amber-800" {...props} />
              ),
              hr: ({ node, ...props }) => (
                <hr className="my-8 border-amber-200" {...props} />
              ),
              table: ({ node, ...props }) => (
                <div className="overflow-x-auto mb-4">
                  <table
                    className="min-w-full border-collapse border border-amber-200"
                    {...props}
                  />
                </div>
              ),
              th: ({ node, ...props }) => (
                <th
                  className="border border-amber-200 bg-amber-50 px-4 py-2 text-left font-semibold text-amber-900"
                  {...props}
                />
              ),
              td: ({ node, ...props }) => (
                <td
                  className="border border-amber-200 px-4 py-2 text-gray-700"
                  {...props}
                />
              ),
            }}
          >
            {result}
          </ReactMarkdown>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/test/components/analysis-skeleton.tsx">
"use client";

import { Skeleton } from "@/components/ui/skeleton";
import { Card, CardContent, CardHeader } from "@/components/ui/card";

export function AnalysisSkeleton() {
  return (
    <div className="max-w-4xl mx-auto p-6">
      <Card className="mb-6 bg-gradient-to-br from-amber-50 to-orange-50 border-amber-200">
        <CardHeader>
          <Skeleton className="h-10 w-3/4" />
        </CardHeader>
        <CardContent className="space-y-3">
          <Skeleton className="h-6 w-2/3" />
          <Skeleton className="h-6 w-1/2" />
          <Skeleton className="h-6 w-1/2" />
          <div className="pt-3 mt-3 border-t border-amber-200">
            <Skeleton className="h-4 w-1/3" />
          </div>
        </CardContent>
      </Card>

      <Card className="mb-6">
        <CardContent className="pt-6 space-y-4">
          <Skeleton className="h-8 w-1/2" />
          <Skeleton className="h-4 w-full" />
          <Skeleton className="h-4 w-full" />
          <Skeleton className="h-4 w-3/4" />
          <Skeleton className="h-8 w-1/2 mt-6" />
          <Skeleton className="h-4 w-full" />
          <Skeleton className="h-4 w-full" />
          <Skeleton className="h-4 w-2/3" />
          <Skeleton className="h-8 w-1/3 mt-6" />
          <Skeleton className="h-4 w-full" />
          <Skeleton className="h-4 w-5/6" />
        </CardContent>
      </Card>

      <div className="flex gap-3 justify-center">
        <Skeleton className="h-10 w-40" />
        <Skeleton className="h-10 w-32" />
      </div>
    </div>
  );
}
</file>

<file path="src/features/test/components/birth-time-picker.tsx">
"use client";

import { Clock } from "lucide-react";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";

interface BirthTimePickerProps {
  value?: string;
  onChange: (time: string) => void;
  disabled?: boolean;
}

export const BirthTimePicker = ({
  value,
  onChange,
  disabled,
}: BirthTimePickerProps) => {
  const hours = Array.from({ length: 24 }, (_, i) => i);
  const minutes = Array.from({ length: 12 }, (_, i) => i * 5);

  const [hour, minute] = value ? value.split(":").map(Number) : [12, 0];

  const handleHourChange = (newHour: string) => {
    onChange(`${newHour.padStart(2, "0")}:${String(minute).padStart(2, "0")}`);
  };

  const handleMinuteChange = (newMinute: string) => {
    onChange(`${String(hour).padStart(2, "0")}:${newMinute.padStart(2, "0")}`);
  };

  return (
    <div className="flex items-center gap-2">
      <Clock className="h-4 w-4 text-muted-foreground" />
      <Select
        value={String(hour)}
        onValueChange={handleHourChange}
        disabled={disabled}
      >
        <SelectTrigger className="w-20">
          <SelectValue />
        </SelectTrigger>
        <SelectContent>
          {hours.map((h) => (
            <SelectItem key={h} value={String(h)}>
              {String(h).padStart(2, "0")}시
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
      <span>:</span>
      <Select
        value={String(minute)}
        onValueChange={handleMinuteChange}
        disabled={disabled}
      >
        <SelectTrigger className="w-20">
          <SelectValue />
        </SelectTrigger>
        <SelectContent>
          {minutes.map((m) => (
            <SelectItem key={m} value={String(m)}>
              {String(m).padStart(2, "0")}분
            </SelectItem>
          ))}
        </SelectContent>
      </Select>
    </div>
  );
};
</file>

<file path="src/features/test/components/empty-test-state.tsx">
"use client";

import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { FileQuestion } from "lucide-react";

export const EmptyTestState = () => {
  const router = useRouter();

  return (
    <div className="mt-12 flex flex-col items-center justify-center space-y-4">
      <FileQuestion className="h-16 w-16 text-muted-foreground" />
      <p className="text-lg text-muted-foreground text-center">
        아직 검사 내역이 없습니다. 새 검사를 시작해보세요!
      </p>
      <Button onClick={() => router.push("/new-test")}>새 검사 시작</Button>
    </div>
  );
};
</file>

<file path="src/features/test/components/gender-selector.tsx">
"use client";

import { Label } from "@/components/ui/label";
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group";

interface GenderSelectorProps {
  value?: string;
  onChange: (gender: "male" | "female") => void;
}

export const GenderSelector = ({ value, onChange }: GenderSelectorProps) => {
  return (
    <RadioGroup
      value={value}
      onValueChange={onChange}
      className="flex gap-4"
    >
      <div className="flex items-center space-x-2">
        <RadioGroupItem value="male" id="male" />
        <Label htmlFor="male" className="cursor-pointer">
          남성
        </Label>
      </div>
      <div className="flex items-center space-x-2">
        <RadioGroupItem value="female" id="female" />
        <Label htmlFor="female" className="cursor-pointer">
          여성
        </Label>
      </div>
    </RadioGroup>
  );
};
</file>

<file path="src/features/test/components/streaming-dialog.tsx">
"use client";

import { useEffect, useRef } from "react";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Loader2, Sparkles, AlertCircle } from "lucide-react";
import { Alert, AlertDescription } from "@/components/ui/alert";

interface StreamingDialogProps {
  open: boolean;
  streamedText: string;
  isStreaming: boolean;
  fallbackMessage: string | null;
  error: string | null;
}

export const StreamingDialog = ({
  open,
  streamedText,
  isStreaming,
  fallbackMessage,
  error,
}: StreamingDialogProps) => {
  const contentRef = useRef<HTMLDivElement>(null);
  const shouldAutoScrollRef = useRef(true);

  useEffect(() => {
    if (shouldAutoScrollRef.current && contentRef.current) {
      contentRef.current.scrollTop = contentRef.current.scrollHeight;
    }
  }, [streamedText]);

  const handleScroll = () => {
    if (!contentRef.current) return;

    const { scrollTop, scrollHeight, clientHeight } = contentRef.current;
    const isNearBottom = scrollHeight - scrollTop - clientHeight < 100;
    shouldAutoScrollRef.current = isNearBottom;
  };

  return (
    <Dialog open={open}>
      <DialogContent
        className="max-w-3xl max-h-[80vh] flex flex-col"
        onInteractOutside={(e) => e.preventDefault()}
        onEscapeKeyDown={(e) => e.preventDefault()}
      >
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            {isStreaming ? (
              <>
                <Loader2 className="h-5 w-5 animate-spin text-amber-600" />
                <span>AI가 사주팔자를 분석하고 있습니다...</span>
              </>
            ) : error ? (
              <>
                <AlertCircle className="h-5 w-5 text-red-500" />
                <span>분석 오류</span>
              </>
            ) : (
              <>
                <Sparkles className="h-5 w-5 text-amber-600" />
                <span>분석 완료!</span>
              </>
            )}
          </DialogTitle>
        </DialogHeader>

        {fallbackMessage && (
          <Alert className="bg-amber-50 border-amber-200">
            <AlertDescription className="text-amber-800">
              {fallbackMessage}
            </AlertDescription>
          </Alert>
        )}

        {error ? (
          <div className="flex-1 flex items-center justify-center p-6">
            <div className="text-center">
              <AlertCircle className="h-12 w-12 text-red-500 mx-auto mb-4" />
              <p className="text-gray-600">{error}</p>
            </div>
          </div>
        ) : (
          <div
            ref={contentRef}
            onScroll={handleScroll}
            className="flex-1 overflow-y-auto p-4 min-h-[300px] max-h-[60vh]"
          >
            {streamedText ? (
              <div className="prose prose-amber max-w-none prose-sm">
                <ReactMarkdown
                  remarkPlugins={[remarkGfm]}
                  components={{
                    h1: ({ node, ...props }) => (
                      <h1
                        className="text-2xl font-bold text-amber-900 mt-6 mb-3"
                        {...props}
                      />
                    ),
                    h2: ({ node, ...props }) => (
                      <h2
                        className="text-xl font-bold text-amber-900 mt-5 mb-2"
                        {...props}
                      />
                    ),
                    h3: ({ node, ...props }) => (
                      <h3
                        className="text-lg font-semibold text-amber-800 mt-3 mb-2"
                        {...props}
                      />
                    ),
                    p: ({ node, ...props }) => (
                      <p className="text-gray-700 mb-3 leading-relaxed" {...props} />
                    ),
                    ul: ({ node, ...props }) => (
                      <ul
                        className="list-disc ml-5 text-gray-700 space-y-1 mb-3"
                        {...props}
                      />
                    ),
                    ol: ({ node, ...props }) => (
                      <ol
                        className="list-decimal ml-5 text-gray-700 space-y-1 mb-3"
                        {...props}
                      />
                    ),
                    li: ({ node, ...props }) => (
                      <li className="text-gray-700" {...props} />
                    ),
                    blockquote: ({ node, ...props }) => (
                      <blockquote
                        className="border-l-4 border-amber-500 pl-3 italic text-gray-600 my-3 bg-amber-50 py-2"
                        {...props}
                      />
                    ),
                    strong: ({ node, ...props }) => (
                      <strong className="font-bold text-amber-900" {...props} />
                    ),
                    em: ({ node, ...props }) => (
                      <em className="italic text-amber-800" {...props} />
                    ),
                  }}
                >
                  {streamedText}
                </ReactMarkdown>
                {isStreaming && (
                  <span className="inline-block w-2 h-4 bg-amber-600 animate-pulse ml-1" />
                )}
              </div>
            ) : (
              <div className="flex items-center justify-center h-full">
                <div className="text-center">
                  <Loader2 className="h-8 w-8 animate-spin text-amber-600 mx-auto mb-4" />
                  <p className="text-gray-500">분석을 시작하고 있습니다...</p>
                </div>
              </div>
            )}
          </div>
        )}
      </DialogContent>
    </Dialog>
  );
};
</file>

<file path="src/features/test/components/test-card-list.tsx">
"use client";

import { TestCard } from "./test-card";
import { EmptyTestState } from "./empty-test-state";
import { Skeleton } from "@/components/ui/skeleton";
import type { TestListResponse } from "../lib/dto";

type TestCardListProps = {
  tests: TestListResponse["tests"];
  isLoading: boolean;
  searchQuery: string;
  onClearSearch: () => void;
};

export const TestCardList = ({
  tests,
  isLoading,
  searchQuery,
  onClearSearch,
}: TestCardListProps) => {
  if (isLoading) {
    return (
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
        {Array.from({ length: 6 }).map((_, i) => (
          <Skeleton key={i} className="h-48 rounded-lg" />
        ))}
      </div>
    );
  }

  if (tests.length === 0 && !searchQuery) {
    return <EmptyTestState />;
  }

  if (tests.length === 0 && searchQuery) {
    return (
      <div className="mt-12 text-center">
        <p className="text-muted-foreground">
          &quot;{searchQuery}&quot;에 대한 검색 결과가 없습니다.
        </p>
        <button
          onClick={onClearSearch}
          className="mt-4 text-primary underline hover:text-primary/80"
        >
          검색어 초기화
        </button>
      </div>
    );
  }

  return (
    <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
      {tests.map((test) => (
        <TestCard key={test.id} test={test} />
      ))}
    </div>
  );
};
</file>

<file path="src/features/test/components/test-info-card.tsx">
"use client";

import { useMemo } from "react";
import { format, parseISO, parse } from "date-fns";
import { ko } from "date-fns/locale";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { CalendarIcon, ClockIcon, UserIcon } from "lucide-react";
import type { TestDetailResponse } from "../lib/dto";

interface Props {
  test: TestDetailResponse;
}

export function TestInfoCard({ test }: Props) {
  const formattedBirthDate = useMemo(
    () => format(parseISO(test.birth_date), "yyyy년 MM월 dd일", { locale: ko }),
    [test.birth_date]
  );

  const formattedBirthTime = useMemo(() => {
    if (!test.birth_time) return "시간 미상";
    try {
      const time = parse(test.birth_time, "HH:mm:ss", new Date());
      return format(time, "a h시 mm분", { locale: ko });
    } catch {
      return test.birth_time;
    }
  }, [test.birth_time]);

  const genderLabel = test.gender === "male" ? "남성" : "여성";

  const formattedCreatedAt = useMemo(
    () =>
      format(parseISO(test.created_at), "yyyy년 MM월 dd일 HH시 mm분", {
        locale: ko,
      }),
    [test.created_at]
  );

  return (
    <Card
      className="mb-6 bg-gradient-to-br from-amber-50 to-orange-50 border-amber-200"
      role="region"
      aria-label="검사 대상자 정보"
    >
      <CardHeader>
        <CardTitle className="text-3xl font-bold text-amber-900">
          {test.name}님의 사주팔자 분석
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-3">
        <div className="flex items-center gap-2 text-amber-800">
          <CalendarIcon className="w-5 h-5" aria-hidden="true" />
          <span className="font-medium">생년월일:</span>
          <span>{formattedBirthDate}</span>
        </div>

        <div className="flex items-center gap-2 text-amber-800">
          <ClockIcon className="w-5 h-5" aria-hidden="true" />
          <span className="font-medium">출생시간:</span>
          <span>{formattedBirthTime}</span>
        </div>

        <div className="flex items-center gap-2 text-amber-800">
          <UserIcon className="w-5 h-5" aria-hidden="true" />
          <span className="font-medium">성별:</span>
          <span>{genderLabel}</span>
        </div>

        <div className="text-sm text-amber-600 mt-4 pt-3 border-t border-amber-200">
          분석 일시: {formattedCreatedAt}
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/test/components/test-result-dialog.tsx">
"use client";

import { useRouter } from "next/navigation";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { CheckCircle, XCircle, AlertTriangle, CreditCard } from "lucide-react";

type TestResultDialogProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  result: {
    type: "success" | "error" | "quota_exceeded";
    testId?: string;
    errorMessage?: string;
    errorCode?: string;
  } | null;
};

export const TestResultDialog = ({
  open,
  onOpenChange,
  result,
}: TestResultDialogProps) => {
  const router = useRouter();

  if (!result) return null;

  const handleViewResult = () => {
    if (result.testId) {
      router.push(`/analysis/${result.testId}`);
    }
    onOpenChange(false);
  };

  const handleUpgrade = () => {
    router.push("/subscription");
    onOpenChange(false);
  };

  const handleClose = () => {
    onOpenChange(false);
  };

  if (result.type === "success") {
    return (
      <Dialog open={open} onOpenChange={onOpenChange}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader className="text-center">
            <div className="mx-auto mb-4 flex h-16 w-16 items-center justify-center rounded-full bg-green-100">
              <CheckCircle className="h-10 w-10 text-green-600" />
            </div>
            <DialogTitle className="text-xl">분석이 완료되었습니다!</DialogTitle>
            <DialogDescription className="text-base">
              사주 분석이 성공적으로 완료되었습니다.
              <br />
              결과 페이지에서 상세 분석을 확인하세요.
            </DialogDescription>
          </DialogHeader>
          <DialogFooter className="mt-4">
            <Button onClick={handleViewResult} className="w-full">
              결과 보기
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    );
  }

  if (result.type === "quota_exceeded") {
    return (
      <Dialog open={open} onOpenChange={onOpenChange}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader className="text-center">
            <div className="mx-auto mb-4 flex h-16 w-16 items-center justify-center rounded-full bg-amber-100">
              <AlertTriangle className="h-10 w-10 text-amber-600" />
            </div>
            <DialogTitle className="text-xl">검사 횟수를 모두 사용했습니다</DialogTitle>
            <DialogDescription className="text-base">
              무료 검사 횟수를 모두 사용하셨습니다.
              <br />
              Pro 플랜으로 업그레이드하시면 월 10회의 고품질 검사를 이용하실 수 있습니다.
            </DialogDescription>
          </DialogHeader>
          <div className="mt-4 rounded-lg bg-blue-50 p-4 border border-blue-100">
            <h4 className="font-semibold text-blue-900 flex items-center gap-2 mb-2">
              <CreditCard className="h-4 w-4" />
              Pro 플랜 혜택
            </h4>
            <ul className="text-sm text-blue-700 space-y-1">
              <li>• 월 10회 고품질 검사</li>
              <li>• Gemini 1.5 Pro 모델 사용</li>
              <li>• 더 상세한 분석 결과</li>
            </ul>
          </div>
          <DialogFooter className="mt-4 flex-col gap-2 sm:flex-col">
            <Button onClick={handleUpgrade} className="w-full">
              Pro로 업그레이드 (월 3,900원)
            </Button>
            <Button variant="outline" onClick={handleClose} className="w-full">
              나중에 하기
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    );
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <DialogHeader className="text-center">
          <div className="mx-auto mb-4 flex h-16 w-16 items-center justify-center rounded-full bg-red-100">
            <XCircle className="h-10 w-10 text-red-600" />
          </div>
          <DialogTitle className="text-xl">검사에 실패했습니다</DialogTitle>
          <DialogDescription className="text-base">
            사주 분석 중 오류가 발생했습니다.
          </DialogDescription>
        </DialogHeader>

        <div className="mt-2 rounded-lg bg-red-50 p-4 border border-red-100">
          <h4 className="font-semibold text-red-900 mb-2">오류 상세</h4>
          <p className="text-sm text-red-700">
            {result.errorMessage || "알 수 없는 오류가 발생했습니다."}
          </p>
          {result.errorCode && (
            <p className="text-xs text-red-500 mt-2">
              오류 코드: {result.errorCode}
            </p>
          )}
        </div>

        <div className="mt-2 text-sm text-gray-500">
          <p>문제가 계속되면 잠시 후 다시 시도하거나, 고객센터로 문의해 주세요.</p>
        </div>

        <DialogFooter className="mt-4 flex-col gap-2 sm:flex-col">
          <Button onClick={handleClose} className="w-full">
            다시 시도
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};
</file>

<file path="src/features/test/components/test-search-bar.tsx">
"use client";

import { Input } from "@/components/ui/input";
import { Search } from "lucide-react";

type TestSearchBarProps = {
  value: string;
  onChange: (value: string) => void;
  placeholder?: string;
};

export const TestSearchBar = ({
  value,
  onChange,
  placeholder = "검색하세요",
}: TestSearchBarProps) => {
  return (
    <div className="relative">
      <Search className="absolute left-3 top-1/2 -translate-y-1/2 h-4 w-4 text-muted-foreground" />
      <Input
        type="text"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder={placeholder}
        className="pl-10"
        aria-label="검사 내역 검색"
      />
    </div>
  );
};
</file>

<file path="src/features/test/hooks/useCreateTest.ts">
"use client";

import { useMutation, useQueryClient } from "@tanstack/react-query";
import { apiClient } from "@/lib/remote/api-client";
import type { CreateTestRequest, CreateTestResponse } from "../lib/dto";

export const useCreateTest = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data: CreateTestRequest) => {
      const response = await apiClient.post<CreateTestResponse>(
        "/api/test/create",
        data
      );
      return response.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["test", "list"] });
    },
  });
};
</file>

<file path="src/features/test/hooks/useDeleteTest.ts">
"use client";

import { useMutation, useQueryClient } from "@tanstack/react-query";
import { apiClient } from "@/lib/remote/api-client";

export const useDeleteTest = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (testId: string) => {
      const response = await apiClient.delete(`/api/test/${testId}`);
      return response.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["test", "list"] });
    },
  });
};
</file>

<file path="src/features/test/hooks/useInitTest.ts">
"use client";

import { useMutation, useQueryClient } from "@tanstack/react-query";
import { apiClient } from "@/lib/remote/api-client";
import type { CreateTestRequest, InitTestResponse } from "../lib/dto";

export const useInitTest = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (data: CreateTestRequest) => {
      const response = await apiClient.post<InitTestResponse>(
        "/api/test/init",
        data
      );
      return response.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["test", "list"] });
      queryClient.invalidateQueries({ queryKey: ["subscription"] });
    },
  });
};
</file>

<file path="src/features/test/hooks/useTestDetail.ts">
"use client";

import { useQuery } from "@tanstack/react-query";
import { apiClient } from "@/lib/remote/api-client";
import type { TestDetailResponse } from "../lib/dto";

export const useTestDetail = (testId: string) => {
  return useQuery({
    queryKey: ["test", "detail", testId],
    queryFn: async () => {
      const response = await apiClient.get<TestDetailResponse>(
        `/api/test/${testId}`
      );
      return response.data;
    },
    enabled: !!testId,
  });
};
</file>

<file path="src/features/test/hooks/useTestList.ts">
"use client";

import { useQuery } from "@tanstack/react-query";
import { apiClient } from "@/lib/remote/api-client";
import type { TestListResponse } from "../lib/dto";

type UseTestListParams = {
  name?: string;
  limit?: number;
  offset?: number;
};

export const useTestList = (params?: UseTestListParams) => {
  return useQuery({
    queryKey: ["test", "list", params],
    queryFn: async () => {
      const response = await apiClient.get<TestListResponse>("/api/test/list", {
        params,
      });
      return response.data;
    },
  });
};
</file>

<file path="src/hooks/use-toast.ts">
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
</file>

<file path="src/lib/gemini/prompt.ts">
import type { SajuInput } from "./types";

export const generateSajuPrompt = (input: SajuInput): string => {
  return `당신은 20년 경력의 전문 사주팔자 상담사입니다.

**입력 정보**:
- 성함: ${input.name}
- 생년월일: ${input.birth_date}
- 출생시간: ${input.birth_time || "미상"}
- 성별: ${input.gender === "male" ? "남성" : "여성"}

**분석 요구사항**:
1️⃣ 천간(天干)과 지지(地支) 계산
2️⃣ 오행(五行) 분석 (목, 화, 토, 금, 수)
3️⃣ 대운(大運)과 세운(歲運) 해석
4️⃣ 전반적인 성격, 재운, 건강운, 연애운 분석

**출력 형식**: 마크다운

**금지 사항**:
- 의료·법률 조언
- 확정적 미래 예측
- 부정적·공격적 표현`;
};
</file>

<file path="src/lib/openai/client.ts">
import { openai } from "@ai-sdk/openai";
import { streamText } from "ai";
import { generateSajuPrompt } from "../gemini/prompt";
import type { SajuInput } from "../gemini/types";

export type OpenAIModel = "gpt-4.1-mini";

export const streamOpenAIAnalysis = async (
  input: SajuInput,
  model: OpenAIModel = "gpt-4.1-mini"
) => {
  const prompt = generateSajuPrompt(input);

  const result = streamText({
    model: openai(model),
    prompt,
    temperature: 0.7,
  });

  return result;
};
</file>

<file path="src/lib/supabase/browser-client.ts">
"use client";

import { createBrowserClient } from "@supabase/ssr";
import type { SupabaseClient } from "@supabase/supabase-js";
import { env } from "@/constants/env";
import type { Database } from "./types";

let client: SupabaseClient<Database> | null = null;

export const getSupabaseBrowserClient = () => {
  if (!client) {
    client = createBrowserClient<Database>(
      env.NEXT_PUBLIC_SUPABASE_URL,
      env.NEXT_PUBLIC_SUPABASE_ANON_KEY
    );
  }

  return client;
};
</file>

<file path="src/lib/supabase/client.ts">
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}
</file>

<file path="src/lib/supabase/server-client.ts">
import { cookies } from "next/headers";
import { createServerClient } from "@supabase/ssr";
import type { SupabaseClient } from "@supabase/supabase-js";
import { env } from "@/constants/env";
import type { Database } from "./types";

type WritableCookieStore = Awaited<ReturnType<typeof cookies>> & {
  set?: (options: {
    name: string;
    value: string;
    path?: string;
    expires?: Date;
    maxAge?: number;
    httpOnly?: boolean;
    sameSite?: "lax" | "strict" | "none";
    secure?: boolean;
  }) => void;
};

export const createSupabaseServerClient = async (): Promise<
  SupabaseClient<Database>
> => {
  const cookieStore = (await cookies()) as WritableCookieStore;

  return createServerClient<Database>(
    env.NEXT_PUBLIC_SUPABASE_URL,
    env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => {
            if (typeof cookieStore.set === "function") {
              cookieStore.set({ name, value, ...options });
            }
          });
        },
      },
    }
  );
};
</file>

<file path="src/lib/supabase/server.ts">
import "server-only";

import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createClient() {
  const cookieStore = await cookies();

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            );
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  );
}

export async function createPureClient() {
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      cookies: {
        getAll() {
          return [];
        },
        setAll() {},
      },
    }
  );
}
</file>

<file path="src/lib/supabase/types.ts">
export type Database = Record<string, never>;

export type SupabaseUserMetadata = Record<string, unknown>;
</file>

<file path="src/lib/toss/client.ts">
import axios from "axios";
import type { ChargeTossPaymentParams, ChargeTossPaymentResult } from "./types";

const TOSS_API_BASE_URL = "https://api.tosspayments.com/v1";

const getTossClient = () => {
  const secretKey = process.env.TOSS_SECRET_KEY;

  if (!secretKey) {
    throw new Error("TOSS_SECRET_KEY is not defined");
  }

  return axios.create({
    baseURL: TOSS_API_BASE_URL,
    headers: {
      "Content-Type": "application/json",
      Authorization: `Basic ${Buffer.from(`${secretKey}:`).toString("base64")}`,
    },
  });
};

export const chargeTossPayment = async (
  params: ChargeTossPaymentParams
): Promise<ChargeTossPaymentResult> => {
  try {
    const tossClient = getTossClient();

    await tossClient.post("/billing", {
      billingKey: params.billing_key,
      customerEmail: params.customer_email,
      amount: params.amount,
      orderId: `order_${Date.now()}`,
      orderName: "Saju피아 Pro 구독",
    });

    return { success: true };
  } catch (error: unknown) {
    const errorMessage =
      axios.isAxiosError(error) && error.response?.data?.message
        ? error.response.data.message
        : "결제 실패";

    return {
      success: false,
      error: errorMessage,
    };
  }
};

export const deleteTossBillingKey = async (
  billing_key: string
): Promise<boolean> => {
  try {
    const tossClient = getTossClient();
    await tossClient.delete(`/billing/${billing_key}`);
    return true;
  } catch (error) {
    console.error("Failed to delete billing key", error);
    return false;
  }
};
</file>

<file path="src/lib/toss/types.ts">
export type ChargeTossPaymentParams = {
  billing_key: string;
  amount: number;
  customer_email: string;
};

export type ChargeTossPaymentResult = {
  success: boolean;
  error?: string;
};

export type RequestBillingKeyParams = {
  customerKey: string;
  successUrl: string;
  failUrl: string;
};
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
</file>

<file path="supabase/migrations/0001_create_example_table.sql">
-- Migration: create example table for backend reference implementation
-- Ensures pgcrypto available for gen_random_uuid
create extension if not exists "pgcrypto";

create table if not exists public.example (
  id uuid primary key default gen_random_uuid(),
  full_name text,
  avatar_url text,
  bio text,
  updated_at timestamptz not null default now()
);

comment on table public.example is 'Example table used by the hono + next.js starter backend layer.';

insert into public.example (full_name, avatar_url, bio)
values
  (
    'Jane Example',
    'https://picsum.photos/seed/jane-example/200/200',
    'Demonstration record generated by the starter migration.'
  )
  on conflict do nothing;

ALTER TABLE IF EXISTS public.example DISABLE ROW LEVEL SECURITY;
</file>

<file path="supabase/migrations/0002_create_saju_tables.sql">
-- =============================================================================
-- Saju피아 데이터베이스 마이그레이션
-- 실행 방법: Supabase SQL Editor에서 전체 스크립트 실행
-- 버전: 1.0
-- 작성일: 2025-12-12
-- =============================================================================

-- pgcrypto 확장 활성화 (UUID 생성용)
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- =============================================================================
-- 1. ENUM 타입 생성
-- =============================================================================

-- plan_type: 구독 플랜 타입
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'plan_type') THEN
    CREATE TYPE plan_type AS ENUM ('free', 'pro');
  END IF;
END $$;

-- gender_type: 성별 타입
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'gender_type') THEN
    CREATE TYPE gender_type AS ENUM ('male', 'female');
  END IF;
END $$;

-- =============================================================================
-- 2. users 테이블 (사용자)
-- =============================================================================

CREATE TABLE IF NOT EXISTS public.users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  clerk_user_id TEXT UNIQUE NOT NULL,
  email TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- 인덱스
CREATE UNIQUE INDEX IF NOT EXISTS idx_users_clerk_id ON public.users(clerk_user_id);

-- RLS 비활성화 (Service Role Key 사용)
ALTER TABLE IF EXISTS public.users DISABLE ROW LEVEL SECURITY;

COMMENT ON TABLE public.users IS 'Clerk 인증 사용자 정보';
COMMENT ON COLUMN public.users.clerk_user_id IS 'Clerk에서 제공하는 고유 사용자 ID';
COMMENT ON COLUMN public.users.email IS '사용자 이메일 주소';

-- =============================================================================
-- 3. subscriptions 테이블 (구독)
-- =============================================================================

CREATE TABLE IF NOT EXISTS public.subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID UNIQUE NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,

  -- 구독 정보
  plan plan_type NOT NULL DEFAULT 'free',
  remaining_tests INTEGER NOT NULL DEFAULT 3,

  -- Pro 플랜 전용 (NULL 가능)
  billing_key TEXT,
  next_billing_date DATE,
  cancel_at_period_end BOOLEAN NOT NULL DEFAULT false,

  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- 제약 조건
  CONSTRAINT chk_remaining_tests CHECK (remaining_tests >= 0)
);

-- 인덱스
CREATE UNIQUE INDEX IF NOT EXISTS idx_subscriptions_user_id ON public.subscriptions(user_id);

-- Partial Index: Cron 작업에서 결제 대상 조회 최적화
CREATE INDEX IF NOT EXISTS idx_subscriptions_billing
  ON public.subscriptions(next_billing_date)
  WHERE plan = 'pro' AND cancel_at_period_end = false;

-- RLS 비활성화 (Service Role Key 사용)
ALTER TABLE IF EXISTS public.subscriptions DISABLE ROW LEVEL SECURITY;

COMMENT ON TABLE public.subscriptions IS '사용자 구독 정보';
COMMENT ON COLUMN public.subscriptions.plan IS 'free: 무료 플랜 (3회), pro: 유료 플랜 (10회/월)';
COMMENT ON COLUMN public.subscriptions.remaining_tests IS '남은 검사 횟수';
COMMENT ON COLUMN public.subscriptions.billing_key IS '토스페이먼츠 빌링키 (Pro 전용)';
COMMENT ON COLUMN public.subscriptions.next_billing_date IS '다음 결제일 (Pro 전용)';
COMMENT ON COLUMN public.subscriptions.cancel_at_period_end IS '결제일에 구독 취소 예정 여부';

-- =============================================================================
-- 4. tests 테이블 (사주 검사 내역)
-- =============================================================================

CREATE TABLE IF NOT EXISTS public.tests (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,

  -- 검사 대상자 정보
  name TEXT NOT NULL,
  birth_date DATE NOT NULL,
  birth_time TIME,
  gender gender_type NOT NULL,

  -- AI 분석 결과
  analysis_result TEXT,

  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- 제약 조건
  CONSTRAINT chk_birth_date CHECK (birth_date <= CURRENT_DATE)
);

-- 복합 인덱스: 대시보드 검사 목록 조회 최적화
CREATE INDEX IF NOT EXISTS idx_tests_user_created
  ON public.tests(user_id, created_at DESC);

-- 인덱스: 이름 검색
CREATE INDEX IF NOT EXISTS idx_tests_name ON public.tests(name);

-- RLS 비활성화 (Service Role Key 사용)
ALTER TABLE IF EXISTS public.tests DISABLE ROW LEVEL SECURITY;

COMMENT ON TABLE public.tests IS '사주 검사 내역';
COMMENT ON COLUMN public.tests.name IS '검사 대상자 이름';
COMMENT ON COLUMN public.tests.birth_date IS '생년월일';
COMMENT ON COLUMN public.tests.birth_time IS '출생 시간 (모를 경우 NULL)';
COMMENT ON COLUMN public.tests.gender IS '성별 (male/female)';
COMMENT ON COLUMN public.tests.analysis_result IS 'Gemini AI 분석 결과 (마크다운)';

-- =============================================================================
-- 5. updated_at 자동 갱신 트리거
-- =============================================================================

-- 트리거 함수 생성
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- users 테이블 트리거
DROP TRIGGER IF EXISTS users_updated_at ON public.users;
CREATE TRIGGER users_updated_at
  BEFORE UPDATE ON public.users
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- subscriptions 테이블 트리거
DROP TRIGGER IF EXISTS subscriptions_updated_at ON public.subscriptions;
CREATE TRIGGER subscriptions_updated_at
  BEFORE UPDATE ON public.subscriptions
  FOR EACH ROW EXECUTE FUNCTION update_updated_at();

-- =============================================================================
-- 6. 완료 메시지
-- =============================================================================

DO $$
BEGIN
  RAISE NOTICE '==============================================';
  RAISE NOTICE 'Saju피아 데이터베이스 마이그레이션 완료!';
  RAISE NOTICE '==============================================';
  RAISE NOTICE '생성된 테이블:';
  RAISE NOTICE '  - public.users (사용자)';
  RAISE NOTICE '  - public.subscriptions (구독)';
  RAISE NOTICE '  - public.tests (검사 내역)';
  RAISE NOTICE '==============================================';
END $$;
</file>

<file path="supabase/migrations/0003_add_payments_table.sql">
-- =============================================================================
-- Payments 테이블 및 Subscriptions 확장 마이그레이션
-- 실행 방법: Supabase SQL Editor에서 전체 스크립트 실행
-- 버전: 1.0
-- 작성일: 2025-12-12
-- =============================================================================

-- =============================================================================
-- 1. subscription_status ENUM 타입 생성
-- =============================================================================

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'subscription_status') THEN
    CREATE TYPE subscription_status AS ENUM ('active', 'canceled', 'past_due', 'inactive');
  END IF;
END $$;

-- =============================================================================
-- 2. subscriptions 테이블에 컬럼 추가
-- =============================================================================

-- status 컬럼 추가
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public'
    AND table_name = 'subscriptions'
    AND column_name = 'status'
  ) THEN
    ALTER TABLE public.subscriptions
    ADD COLUMN status subscription_status NOT NULL DEFAULT 'inactive';
  END IF;
END $$;

-- current_period_start 컬럼 추가
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public'
    AND table_name = 'subscriptions'
    AND column_name = 'current_period_start'
  ) THEN
    ALTER TABLE public.subscriptions
    ADD COLUMN current_period_start TIMESTAMPTZ;
  END IF;
END $$;

-- current_period_end 컬럼 추가
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public'
    AND table_name = 'subscriptions'
    AND column_name = 'current_period_end'
  ) THEN
    ALTER TABLE public.subscriptions
    ADD COLUMN current_period_end TIMESTAMPTZ;
  END IF;
END $$;

COMMENT ON COLUMN public.subscriptions.status IS '구독 상태 (active: 활성, canceled: 취소됨, past_due: 결제 실패, inactive: 비활성)';
COMMENT ON COLUMN public.subscriptions.current_period_start IS '현재 결제 기간 시작일';
COMMENT ON COLUMN public.subscriptions.current_period_end IS '현재 결제 기간 종료일';

-- =============================================================================
-- 3. payments 테이블 생성 (결제 내역)
-- =============================================================================

CREATE TABLE IF NOT EXISTS public.payments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES public.users(id) ON DELETE CASCADE,

  -- 토스페이먼츠 결제 정보
  payment_key TEXT NOT NULL,
  order_id TEXT NOT NULL,
  amount INTEGER NOT NULL,
  status TEXT NOT NULL,
  method TEXT,
  approved_at TIMESTAMPTZ,

  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- 제약 조건
  CONSTRAINT chk_amount_positive CHECK (amount > 0)
);

-- 인덱스
CREATE INDEX IF NOT EXISTS idx_payments_user_id ON public.payments(user_id);
CREATE INDEX IF NOT EXISTS idx_payments_order_id ON public.payments(order_id);
CREATE UNIQUE INDEX IF NOT EXISTS idx_payments_payment_key ON public.payments(payment_key);

-- RLS 비활성화 (Service Role Key 사용)
ALTER TABLE IF EXISTS public.payments DISABLE ROW LEVEL SECURITY;

COMMENT ON TABLE public.payments IS '결제 내역';
COMMENT ON COLUMN public.payments.payment_key IS '토스페이먼츠 결제 키';
COMMENT ON COLUMN public.payments.order_id IS '주문 ID';
COMMENT ON COLUMN public.payments.amount IS '결제 금액';
COMMENT ON COLUMN public.payments.status IS '결제 상태 (DONE, CANCELED 등)';
COMMENT ON COLUMN public.payments.method IS '결제 수단 (카드, 계좌이체 등)';
COMMENT ON COLUMN public.payments.approved_at IS '결제 승인 시간';

-- =============================================================================
-- 4. 완료 메시지
-- =============================================================================

DO $$
BEGIN
  RAISE NOTICE '==============================================';
  RAISE NOTICE 'Payments 마이그레이션 완료!';
  RAISE NOTICE '==============================================';
  RAISE NOTICE '변경 사항:';
  RAISE NOTICE '  - public.subscriptions에 status, current_period_start, current_period_end 컬럼 추가';
  RAISE NOTICE '  - public.payments 테이블 생성';
  RAISE NOTICE '==============================================';
END $$;
</file>

<file path="supabase/migrations/0004_setup_pg_cron_billing.sql">
-- ============================================
-- Supabase pg_cron + pg_net 설정
-- 매일 02:00 KST (17:00 UTC 전날)에 정기결제 실행
-- ============================================

-- 1. 필요한 확장 활성화
CREATE EXTENSION IF NOT EXISTS pg_cron;
CREATE EXTENSION IF NOT EXISTS pg_net;

-- ============================================
-- 중요: 아래 SQL은 Supabase Dashboard > SQL Editor에서
-- 실제 값을 대입하여 별도 실행해야 합니다.
-- ============================================

-- 2. 기존 cron job이 있으면 삭제 (중복 방지)
-- DO $$
-- BEGIN
--   PERFORM cron.unschedule('daily-billing-job');
-- EXCEPTION WHEN OTHERS THEN
--   NULL;
-- END $$;

-- 3. daily-billing cron job 등록
-- 매일 17:00 UTC = 02:00 KST (다음날)
-- 실제 URL과 SECRET을 대입하여 실행하세요:
--
-- SELECT cron.schedule(
--   'daily-billing-job',
--   '0 17 * * *',
--   $$
--   SELECT net.http_post(
--     url := 'https://YOUR_DOMAIN.vercel.app/api/cron/daily-billing',
--     headers := '{
--       "Content-Type": "application/json",
--       "Authorization": "Bearer YOUR_CRON_SECRET_HERE"
--     }'::jsonb,
--     body := '{}'::jsonb
--   );
--   $$
-- );

-- ============================================
-- cron job 관리 명령어
-- ============================================
-- 등록된 job 확인:
-- SELECT * FROM cron.job;
--
-- 실행 기록 확인:
-- SELECT * FROM cron.job_run_details ORDER BY start_time DESC LIMIT 10;
--
-- job 삭제:
-- SELECT cron.unschedule('daily-billing-job');
--
-- ============================================
</file>

<file path="supabase/scripts/setup_daily_billing_cron.sql">
-- ============================================
-- Supabase pg_cron 정기결제 설정 스크립트
-- ============================================
--
-- 사용법:
-- 1. 아래 변수들을 실제 값으로 교체
-- 2. Supabase Dashboard > SQL Editor에서 실행
--
-- ============================================

-- [설정 변수] 아래 값들을 실제 값으로 교체하세요
-- YOUR_DOMAIN: Vercel 배포 도메인 (예: saju-fullstack.vercel.app)
-- YOUR_CRON_SECRET: .env.local의 CRON_SECRET 값

-- ============================================
-- Step 1: 확장 활성화 (이미 되어있으면 스킵)
-- ============================================
CREATE EXTENSION IF NOT EXISTS pg_cron;
CREATE EXTENSION IF NOT EXISTS pg_net;

-- ============================================
-- Step 2: 기존 job 삭제 (있으면)
-- ============================================
DO $$
BEGIN
  PERFORM cron.unschedule('daily-billing-job');
EXCEPTION WHEN OTHERS THEN
  NULL;
END $$;

-- ============================================
-- Step 3: daily-billing cron job 등록
-- 매일 17:00 UTC = 02:00 KST (다음날)
-- ============================================
SELECT cron.schedule(
  'daily-billing-job',
  '0 17 * * *',
  $$
  SELECT net.http_post(
    url := 'https://saju-fullstack.vercel.app/api/cron/daily-billing',
    headers := '{
      "Content-Type": "application/json",
      "Authorization": "Bearer efe52a907659aa101f34af03777d7398180e9f9ca4103759276a8e7e30239185"
    }'::jsonb,
    body := '{}'::jsonb
  );
  $$
);

-- ============================================
-- Step 4: 등록 확인
-- ============================================
SELECT jobid, jobname, schedule, command
FROM cron.job
WHERE jobname = 'daily-billing-job';
</file>

<file path=".cursorignore">
pnpm-lock.yaml
yarn.lock
package-lock.json
</file>

<file path=".gitignore copy">
# START Ruler Generated Files
/.codex/config.toml
/.codex/config.toml.bak
/AGENTS.md
/AGENTS.md.bak
/CLAUDE.md
/CLAUDE.md.bak
# END Ruler Generated Files

# E2E Tests (불필요한 파일들)
e2e/test-accounts.json
e2e/token-store.json
e2e/integration-test-data.json
test-results/
tests/

/Docs/prd.md
/Docs/Userflow.md

.ruler/
#.ruler/AGENTS.md
#.ruler/supabase.md

.prompt/ 
prompt/
docs/**/usecase-checker.md 
USECASE_CHECKER_SUMMARY.md


.claude/

# Dependencies
node_modules/
/.pnp
.pnp.js

# Testing
/coverage
/test-results/
/playwright-report/
/blob-report/
/playwright/.cache/

# Next.js
/.next/
/out/
next-env.d.ts

# Production
/build
/dist

# Misc
.DS_Store
*.pem

# Debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# Local env files
.env
.env*.local
.env.development.local
.env.test.local
.env.production.local

# Vercel
.vercel

# TypeScript
*.tsbuildinfo

# IDE
.vscode/
.idea/
*.swp
*.swo
*~
.project
.classpath
.settings/
*.sublime-project
*.sublime-workspace

# OS
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}
</file>

<file path="eslint.config.mjs">
import { dirname } from 'path';
import { fileURLToPath } from 'url';
import { FlatCompat } from '@eslint/eslintrc';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends('next/core-web-vitals', 'next/typescript'),
  {
    rules: {
      '@typescript-eslint/no-empty-object-type': 'off',
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-unused-vars': 'off',
    },
  },
];

export default eslintConfig;
</file>

<file path="middleware.ts">
import { NextResponse, type NextRequest } from "next/server";
import { createServerClient } from "@supabase/ssr";
import type { Database } from "@/lib/supabase/types";
import { env } from "@/constants/env";
import {
  LOGIN_PATH,
  isAuthEntryPath,
  shouldProtectPath,
} from "@/constants/auth";
import { match } from "ts-pattern";

const copyCookies = (from: NextResponse, to: NextResponse) => {
  from.cookies.getAll().forEach((cookie) => {
    to.cookies.set({
      name: cookie.name,
      value: cookie.value,
      path: cookie.path,
      expires: cookie.expires,
      httpOnly: cookie.httpOnly,
      maxAge: cookie.maxAge,
      sameSite: cookie.sameSite,
      secure: cookie.secure,
    });
  });

  return to;
};

export async function middleware(request: NextRequest) {
  const response = NextResponse.next({ request });

  const supabase = createServerClient<Database>(
    env.NEXT_PUBLIC_SUPABASE_URL,
    env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll();
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => {
            request.cookies.set({ name, value, ...options });
            response.cookies.set({ name, value, ...options });
          });
        },
      },
    }
  );

  const {
    data: { user },
  } = await supabase.auth.getUser();

  const decision = match({ user, pathname: request.nextUrl.pathname })
    .when(
      ({ user: currentUser, pathname }) =>
        !currentUser && shouldProtectPath(pathname),
      ({ pathname }) => {
        const loginUrl = request.nextUrl.clone();
        loginUrl.pathname = LOGIN_PATH;
        loginUrl.searchParams.set("redirectedFrom", pathname);

        return copyCookies(response, NextResponse.redirect(loginUrl));
      }
    )
    .otherwise(() => response);

  return decision;
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)",
  ],
};
</file>

<file path="next.config.ts">
import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
  /* config options here */
  eslint: {
    ignoreDuringBuilds: true,
  },
  images: {
    remotePatterns: [
      {
        hostname: '**',
      },
    ],
  },
};

export default nextConfig;
</file>

<file path="postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    '@tailwindcss/postcss': {},
  },
};

export default config;
</file>

<file path="ruler.toml">
# Ruler Configuration File
# See https://ai.intellectronica.net/ruler for documentation.

# To specify which agents are active by default when --agents is not used,
# uncomment and populate the following line. If omitted, all agents are active.

default_agents = ["claude","codex", "Qwen"]

# Enable nested rule loading from nested .ruler directories
# When enabled, ruler will search for and process .ruler directories throughout the project hierarchy
# nested = false

# --- Agent Specific Configurations ---
# You can enable/disable agents and override their default output paths here.
# Use lowercase agent identifiers: amp, copilot, claude, codex, cursor, windsurf, cline, aider, kilocode

# [agents.copilot]
# enabled = true
# output_path = ".github/copilot-instructions.md"

# [agents.aider]
# enabled = true
# output_path_instructions = "AGENTS.md"
# output_path_config = ".aider.conf.yml"

# [agents.gemini-cli]
# enabled = true

# --- MCP Servers ---
# Define Model Context Protocol servers here. Two examples:
# 1. A stdio server (local executable)
# 2. A remote server (HTTP-based)

# [mcp_servers.example_stdio]
# command = "node"
# args = ["scripts/your-mcp-server.js"]
# env = { API_KEY = "replace_me" }

# [mcp_servers.example_remote]
# url = "https://api.example.com/mcp"
# headers = { Authorization = "Bearer REPLACE_ME" }

[playwright-cli]
command = "npx"
args = ["playwright", "test", "--project=chromium"]
# 필요 시 환경변수
env = { NODE_ENV = "test" }
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "strictNullChecks": false,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noImplicitAny": false,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="src/app/(landing)/components/hero-section.tsx">
"use client";

import { useState, useEffect } from "react";
import { useRouter } from "next/navigation";
import Image from "next/image";
import { Button } from "@/components/ui/button";
import { useCurrentUser } from "@/features/auth/hooks/useCurrentUser";

export function HeroSection() {
  const { isAuthenticated } = useCurrentUser();
  const router = useRouter();
  const [imageUrl, setImageUrl] = useState("");

  useEffect(() => {
    setImageUrl(`https://picsum.photos/seed/${Date.now()}/1200/600`);
  }, []);

  const handleStartClick = () => {
    if (isAuthenticated) {
      router.push("/dashboard");
    } else {
      router.push("/sign-in");
    }
  };

  const handleLearnMoreClick = () => {
    const element = document.querySelector("#service");
    if (element) {
      element.scrollIntoView({ behavior: "smooth" });
    }
  };

  return (
    <section
      id="hero"
      className="container mx-auto px-4 py-16 md:py-24 lg:py-32"
    >
      <div className="flex flex-col items-center gap-12">
        <div className="flex flex-col items-center gap-6 text-center max-w-3xl">
          <h1 className="text-4xl font-bold tracking-tight text-slate-900 sm:text-5xl md:text-6xl">
            AI가 풀어주는 당신의 사주팔자
          </h1>
          <p className="text-lg text-slate-600 leading-relaxed">
            구글 Gemini AI가 천간·지지를 계산하고, 당신의 운세를 자연어로
            풀어드립니다. 가입 즉시 무료 3회 체험, Pro 구독 시 월 10회 분석
            제공
          </p>
          <div className="flex flex-col gap-3 sm:flex-row">
            <Button onClick={handleStartClick} size="lg" className="w-full sm:w-auto">
              무료 시작하기
            </Button>
            <Button
              onClick={handleLearnMoreClick}
              variant="outline"
              size="lg"
              className="w-full sm:w-auto"
            >
              자세히 알아보기
            </Button>
          </div>
        </div>

        <div className="relative w-full max-w-4xl aspect-[2/1] overflow-hidden rounded-2xl shadow-2xl">
          {imageUrl && (
            <Image
              src={imageUrl}
              alt="대자연 이미지"
              fill
              className="object-cover"
              priority
              onError={(e) => {
                e.currentTarget.src = "https://picsum.photos/1200/600";
              }}
            />
          )}
        </div>
      </div>
    </section>
  );
}
</file>

<file path="src/app/(landing)/components/landing-header.tsx">
"use client";

import { useState } from "react";
import Link from "next/link";
import { useRouter } from "next/navigation";
import { Sparkles, Menu, X } from "lucide-react";
import { useCurrentUser } from "@/features/auth/hooks/useCurrentUser";
import { Button } from "@/components/ui/button";
import { Sheet, SheetContent, SheetTrigger } from "@/components/ui/sheet";

const navLinks = [
  { label: "홈", href: "#hero" },
  { label: "서비스", href: "#service" },
  { label: "가격", href: "#pricing" },
  { label: "FAQ", href: "#faq" },
];

export function LandingHeader() {
  const { isAuthenticated, isLoading } = useCurrentUser();
  const router = useRouter();
  const [isOpen, setIsOpen] = useState(false);

  const handleScroll = (href: string) => {
    const element = document.querySelector(href);
    if (element) {
      element.scrollIntoView({ behavior: "smooth" });
      setIsOpen(false);
    }
  };

  const handleCTAClick = () => {
    if (isAuthenticated) {
      router.push("/dashboard");
    } else {
      router.push("/sign-in");
    }
  };

  return (
    <header className="sticky top-0 z-50 w-full border-b border-slate-200 bg-white/95 backdrop-blur supports-[backdrop-filter]:bg-white/80">
      <div className="container mx-auto flex h-16 items-center justify-between px-4">
        <div className="flex items-center gap-2">
          <Sparkles className="h-6 w-6 text-indigo-600" />
          <span className="text-xl font-bold text-slate-900">Saju피아</span>
        </div>

        <nav className="hidden items-center gap-6 md:flex">
          {navLinks.map((link) => (
            <button
              key={link.href}
              onClick={() => handleScroll(link.href)}
              className="text-sm font-medium text-slate-600 transition-colors hover:text-slate-900"
            >
              {link.label}
            </button>
          ))}
        </nav>

        <div className="hidden md:block">
          {isLoading ? (
            <Button variant="outline" size="sm" disabled>
              로딩 중...
            </Button>
          ) : isAuthenticated ? (
            <Button onClick={handleCTAClick} size="sm">
              대시보드로 이동
            </Button>
          ) : (
            <Button onClick={handleCTAClick} size="sm">
              시작하기
            </Button>
          )}
        </div>

        <Sheet open={isOpen} onOpenChange={setIsOpen}>
          <SheetTrigger asChild className="md:hidden">
            <Button variant="ghost" size="icon">
              <Menu className="h-5 w-5" />
            </Button>
          </SheetTrigger>
          <SheetContent side="right" className="w-64">
            <div className="flex flex-col gap-4 pt-8">
              <div className="flex items-center gap-2 pb-4">
                <Sparkles className="h-6 w-6 text-indigo-600" />
                <span className="text-lg font-bold text-slate-900">
                  Saju피아
                </span>
              </div>
              <nav className="flex flex-col gap-3">
                {navLinks.map((link) => (
                  <button
                    key={link.href}
                    onClick={() => handleScroll(link.href)}
                    className="rounded-md px-3 py-2 text-left text-sm font-medium text-slate-600 transition-colors hover:bg-slate-100 hover:text-slate-900"
                  >
                    {link.label}
                  </button>
                ))}
              </nav>
              <div className="mt-4 pt-4 border-t border-slate-200">
                {isLoading ? (
                  <Button variant="outline" className="w-full" disabled>
                    로딩 중...
                  </Button>
                ) : isAuthenticated ? (
                  <Button onClick={handleCTAClick} className="w-full">
                    대시보드로 이동
                  </Button>
                ) : (
                  <Button onClick={handleCTAClick} className="w-full">
                    시작하기
                  </Button>
                )}
              </div>
            </div>
          </SheetContent>
        </Sheet>
      </div>
    </header>
  );
}
</file>

<file path="src/app/(landing)/components/pricing-section.tsx">
"use client";

import { useRouter } from "next/navigation";
import { Check } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { useCurrentUser } from "@/features/auth/hooks/useCurrentUser";
import { pricingPlans } from "../lib/constants";

export function PricingSection() {
  const { isAuthenticated } = useCurrentUser();
  const router = useRouter();

  const handleFreeClick = () => {
    if (isAuthenticated) {
      router.push("/dashboard");
    } else {
      router.push("/sign-in");
    }
  };

  const handleProClick = () => {
    if (isAuthenticated) {
      router.push("/subscription");
    } else {
      router.push("/sign-in");
    }
  };

  return (
    <section id="pricing" className="py-16 md:py-24">
      <div className="container mx-auto px-4">
        <h2 className="text-3xl font-bold tracking-tight text-center text-slate-900 sm:text-4xl mb-4">
          간단하고 명확한 요금제
        </h2>
        <p className="text-center text-slate-600 mb-12 max-w-2xl mx-auto">
          무료로 시작하거나 Pro 플랜으로 더 많은 혜택을 누리세요
        </p>

        <div className="grid gap-8 md:grid-cols-2 max-w-4xl mx-auto">
          <Card className="border-slate-200 transition-shadow hover:shadow-lg">
            <CardHeader>
              <div className="flex items-center justify-between mb-2">
                <Badge variant="secondary">{pricingPlans.free.badge}</Badge>
              </div>
              <CardTitle className="text-2xl">{pricingPlans.free.name}</CardTitle>
              <CardDescription>
                <span className="text-3xl font-bold text-slate-900">
                  {pricingPlans.free.price}원
                </span>
              </CardDescription>
            </CardHeader>
            <CardContent>
              <ul className="space-y-3">
                {pricingPlans.free.features.map((feature) => (
                  <li key={feature} className="flex items-start gap-2">
                    <Check className="h-5 w-5 text-green-600 flex-shrink-0 mt-0.5" />
                    <span className="text-slate-600">{feature}</span>
                  </li>
                ))}
              </ul>
            </CardContent>
            <CardFooter>
              <Button onClick={handleFreeClick} variant="outline" className="w-full">
                {pricingPlans.free.cta}
              </Button>
            </CardFooter>
          </Card>

          <Card className="border-indigo-200 bg-indigo-50/30 transition-shadow hover:shadow-lg relative">
            <CardHeader>
              <div className="flex items-center justify-between mb-2">
                <Badge className="bg-indigo-600">{pricingPlans.pro.badge}</Badge>
              </div>
              <CardTitle className="text-2xl">{pricingPlans.pro.name}</CardTitle>
              <CardDescription>
                <span className="text-3xl font-bold text-slate-900">
                  {pricingPlans.pro.price.toLocaleString()}원
                </span>
                <span className="text-slate-600"> /월</span>
              </CardDescription>
            </CardHeader>
            <CardContent>
              <ul className="space-y-3">
                {pricingPlans.pro.features.map((feature) => (
                  <li key={feature} className="flex items-start gap-2">
                    <Check className="h-5 w-5 text-green-600 flex-shrink-0 mt-0.5" />
                    <span className="text-slate-600">{feature}</span>
                  </li>
                ))}
              </ul>
            </CardContent>
            <CardFooter>
              <Button onClick={handleProClick} className="w-full">
                {pricingPlans.pro.cta}
              </Button>
            </CardFooter>
          </Card>
        </div>

        <div className="mt-12 text-center space-y-2 max-w-3xl mx-auto">
          <p className="text-xs text-slate-500">
            * 구독 취소 시 환불 불가, 다음 결제일까지 서비스 이용 가능
          </p>
          <p className="text-xs text-slate-500">
            * 결제 실패 시 즉시 구독 해지 처리
          </p>
        </div>
      </div>
    </section>
  );
}
</file>

<file path="src/app/(protected)/dashboard/page.tsx">
"use client";

import { useState } from "react";
import { TestSearchBar } from "@/features/test/components/test-search-bar";
import { TestCardList } from "@/features/test/components/test-card-list";
import { useTestList } from "@/features/test/hooks/useTestList";

export default function DashboardPage() {
  const [searchQuery, setSearchQuery] = useState("");

  const { data, isLoading, error } = useTestList({
    name: searchQuery || undefined,
    limit: 20,
  });

  return (
    <div className="container mx-auto px-6 py-8">
      <div className="mb-8">
        <h1 className="text-3xl font-bold tracking-tight">
          과거에 수행한 사주 팔자 검사 내역을 확인할 수 있습니다.
        </h1>
      </div>

      <TestSearchBar
        value={searchQuery}
        onChange={setSearchQuery}
        placeholder="성함으로 검색하세요"
      />

      {!isLoading && data && (
        <div className="mt-6 mb-4 text-sm text-muted-foreground">
          총 {data.total}건의 검사 내역
        </div>
      )}

      <TestCardList
        tests={data?.tests || []}
        isLoading={isLoading}
        searchQuery={searchQuery}
        onClearSearch={() => setSearchQuery("")}
      />

      {error && (
        <div className="mt-8 text-center text-destructive">
          검사 내역을 불러오는 데 실패했습니다.
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/app/sign-up/[[...sign-up]]/page.tsx">
"use client";

import { useEffect } from "react";
import { useRouter } from "next/navigation";
import { SignUp, useUser } from "@clerk/nextjs";

type SignUpPageProps = {
  params: Promise<Record<string, never>>;
};

export default function SignUpPage({ params }: SignUpPageProps) {
  void params;
  const { isSignedIn, isLoaded } = useUser();
  const router = useRouter();

  useEffect(() => {
    if (isLoaded && isSignedIn) {
      router.replace("/dashboard");
    }
  }, [isLoaded, isSignedIn, router]);

  if (!isLoaded || isSignedIn) {
    return null;
  }

  return (
    <div className="flex min-h-screen items-center justify-center bg-slate-50">
      <SignUp
        appearance={{
          elements: {
            rootBox: "mx-auto",
            card: "shadow-xl",
          },
        }}
        routing="path"
        path="/sign-up"
        signInUrl="/sign-in"
        fallbackRedirectUrl="/dashboard"
      />
    </div>
  );
}
</file>

<file path="src/app/globals.css">
@import "tailwindcss";

@plugin "@tailwindcss/typography";
@plugin "tailwindcss-animate";

@custom-variant dark (&:where(.dark, .dark *));

@utility container {
  margin-inline: auto;
  width: 100%;
  padding-inline: 2rem;
  @media (width >= 1400px) {
    max-width: 1400px;
  }
}

@theme {
  --color-border: hsl(var(--border));
  --color-input: hsl(var(--input));
  --color-ring: hsl(var(--ring));
  --color-background: hsl(var(--background));
  --color-foreground: hsl(var(--foreground));

  --color-primary: hsl(var(--primary));
  --color-primary-foreground: hsl(var(--primary-foreground));

  --color-secondary: hsl(var(--secondary));
  --color-secondary-foreground: hsl(var(--secondary-foreground));

  --color-destructive: hsl(var(--destructive));
  --color-destructive-foreground: hsl(var(--destructive-foreground));

  --color-muted: hsl(var(--muted));
  --color-muted-foreground: hsl(var(--muted-foreground));

  --color-accent: hsl(var(--accent));
  --color-accent-foreground: hsl(var(--accent-foreground));

  --color-popover: hsl(var(--popover));
  --color-popover-foreground: hsl(var(--popover-foreground));

  --color-card: hsl(var(--card));
  --color-card-foreground: hsl(var(--card-foreground));

  --radius-lg: var(--radius);
  --radius-md: calc(var(--radius) - 2px);
  --radius-sm: calc(var(--radius) - 4px);

  --animate-accordion-down: accordion-down 0.2s ease-out;
  --animate-accordion-up: accordion-up 0.2s ease-out;

  @keyframes accordion-down {
    from {
      height: 0;
    }
    to {
      height: var(--radix-accordion-content-height);
    }
  }
  @keyframes accordion-up {
    from {
      height: var(--radix-accordion-content-height);
    }
    to {
      height: 0;
    }
  }
}

/*
  The default border color has changed to `currentcolor` in Tailwind CSS v4,
  so we've added these compatibility styles to make sure everything still
  looks the same as it did with Tailwind CSS v3.

  If we ever want to remove these styles, we need to add an explicit border
  color utility to any element that depends on these defaults.
*/
@layer base {
  *,
  ::after,
  ::before,
  ::backdrop,
  ::file-selector-button {
    border-color: var(--color-gray-200, currentcolor);
  }
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --radius: 0.5rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
  }

  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
  html {
    scroll-behavior: smooth;
  }
}
</file>

<file path="src/app/page.tsx">
"use client";

import { useEffect } from "react";
import { LandingHeader } from "./(landing)/components/landing-header";
import { HeroSection } from "./(landing)/components/hero-section";
import { ServiceSection } from "./(landing)/components/service-section";
import { PricingSection } from "./(landing)/components/pricing-section";
import { FaqSection } from "./(landing)/components/faq-section";

export default function Home() {
  useEffect(() => {
    const hash = window.location.hash;
    if (hash) {
      const element = document.querySelector(hash);
      if (element) {
        element.scrollIntoView({ behavior: "smooth" });
      }
    }
  }, []);

  return (
    <div className="min-h-screen bg-white">
      <LandingHeader />
      <main>
        <HeroSection />
        <ServiceSection />
        <PricingSection />
        <FaqSection />
      </main>
    </div>
  );
}
</file>

<file path="src/backend/config/index.ts">
import { z } from 'zod';
import type { AppConfig } from '@/backend/hono/context';

const envSchema = z.object({
  SUPABASE_URL: z.string().url(),
  SUPABASE_SERVICE_ROLE_KEY: z.string().min(1),
});

let cachedConfig: AppConfig | null = null;

export const getAppConfig = (): AppConfig => {
  if (cachedConfig) {
    return cachedConfig;
  }

  const parsed = envSchema.safeParse({
    SUPABASE_URL: process.env.SUPABASE_URL || process.env.NEXT_PUBLIC_SUPABASE_URL,
    SUPABASE_SERVICE_ROLE_KEY: process.env.SUPABASE_SERVICE_ROLE_KEY,
  });

  if (!parsed.success) {
    const messages = parsed.error.issues
      .map((issue) => `${issue.path.join('.') || 'config'}: ${issue.message}`)
      .join('; ');
    throw new Error(`Invalid backend configuration: ${messages}`);
  }

  cachedConfig = {
    supabase: {
      url: parsed.data.SUPABASE_URL,
      serviceRoleKey: parsed.data.SUPABASE_SERVICE_ROLE_KEY,
    },
  } satisfies AppConfig;

  return cachedConfig;
};
</file>

<file path="src/components/layout/global-nav.tsx">
"use client";

import Link from "next/link";
import { usePathname } from "next/navigation";
import { cn } from "@/lib/utils";
import { Home, PlusCircle, Sparkles } from "lucide-react";
import { NavFooter } from "./nav-footer";

const menuItems = [
  {
    href: "/dashboard",
    label: "대시보드",
    icon: Home,
  },
  {
    href: "/new-test",
    label: "새 검사",
    icon: PlusCircle,
  },
];

export function GlobalNav() {
  const pathname = usePathname();

  return (
    <nav className="h-full flex flex-col">
      <div className="p-6 border-b">
        <div className="flex items-center gap-2">
          <Sparkles className="w-6 h-6 text-primary" />
          <h1 className="text-2xl font-bold">Saju피아</h1>
        </div>
      </div>

      <div className="flex-1 py-4">
        {menuItems.map((item) => {
          const Icon = item.icon;
          const isActive = pathname === item.href;

          return (
            <Link
              key={item.href}
              href={item.href}
              className={cn(
                "flex items-center gap-3 px-6 py-3 text-sm font-medium transition-colors",
                isActive
                  ? "bg-accent text-accent-foreground"
                  : "text-muted-foreground hover:bg-accent/50 hover:text-foreground"
              )}
            >
              <Icon className="w-5 h-5" />
              {item.label}
            </Link>
          );
        })}
      </div>

      <NavFooter />
    </nav>
  );
}
</file>

<file path="src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
        "icon-sm": "size-8",
        "icon-lg": "size-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
</file>

<file path="src/constants/auth.ts">
import { match } from "ts-pattern";

const PUBLIC_PATHS = ["/", "/sign-in", "/sign-up"] as const;
const PUBLIC_PREFIXES = ["/_next", "/api", "/favicon", "/static", "/docs", "/images"] as const;

export const LOGIN_PATH = "/sign-in";
export const SIGNUP_PATH = "/sign-up";
export const AUTH_ENTRY_PATHS = [LOGIN_PATH, SIGNUP_PATH] as const;
export const isAuthEntryPath = (
  pathname: string
): pathname is (typeof AUTH_ENTRY_PATHS)[number] =>
  AUTH_ENTRY_PATHS.includes(pathname as (typeof AUTH_ENTRY_PATHS)[number]);

export const isAuthPublicPath = (pathname: string) => {
  const normalized = pathname.toLowerCase();

  return match(normalized)
    .when(
      (path) => PUBLIC_PATHS.some((publicPath) => publicPath === path),
      () => true
    )
    .when(
      (path) => PUBLIC_PREFIXES.some((prefix) => path.startsWith(prefix)),
      () => true
    )
    .otherwise(() => false);
};

export const shouldProtectPath = (pathname: string) => !isAuthPublicPath(pathname);
</file>

<file path="src/features/auth/backend/route.ts">
import type { Hono } from "hono";
import { zValidator } from "@hono/zod-validator";
import type { AppEnv } from "@/backend/hono/context";
import { respond } from "@/backend/http/response";
import {
  clerkWebhookSchema,
  type ClerkUserCreated,
  type ClerkUserDeleted,
} from "./schema";
import { handleUserCreated, handleUserDeleted } from "./service";

export const registerAuthRoutes = (app: Hono<AppEnv>) => {
  app.post(
    "/api/auth/webhook",
    zValidator("json", clerkWebhookSchema) as never,
    async (c) => {
      const body = await c.req.json();
      const parsed = clerkWebhookSchema.parse(body);

      if (parsed.type === "user.created") {
        const userData: ClerkUserCreated = parsed.data as ClerkUserCreated;
        return respond(c, await handleUserCreated(c, userData));
      }

      if (parsed.type === "user.deleted") {
        const userData: ClerkUserDeleted = parsed.data as ClerkUserDeleted;
        return respond(c, await handleUserDeleted(c, userData));
      }

      return c.json({ message: "Webhook received" }, 200);
    }
  );
};
</file>

<file path="src/features/auth/backend/schema.ts">
import { z } from "zod";

export const clerkWebhookSchema = z.discriminatedUnion("type", [
  z.object({
    type: z.literal("user.created"),
    data: z.object({
      id: z.string(),
      email_addresses: z
        .array(
          z.object({
            email_address: z.string().email(),
          })
        )
        .min(1),
    }),
  }),
  z.object({
    type: z.literal("user.deleted"),
    data: z.object({
      id: z.string(),
    }),
  }),
]);

export type ClerkWebhookPayload = z.infer<typeof clerkWebhookSchema>;
export type ClerkUserCreated = Extract<
  ClerkWebhookPayload,
  { type: "user.created" }
>["data"];
export type ClerkUserDeleted = Extract<
  ClerkWebhookPayload,
  { type: "user.deleted" }
>["data"];
</file>

<file path="src/features/auth/backend/service.ts">
import type { AppContext } from "@/backend/hono/context";
import { success, failure } from "@/backend/http/response";
import type { ClerkUserCreated, ClerkUserDeleted } from "./schema";
import { authErrorCodes } from "./error";
import { deleteTossBillingKey } from "@/lib/toss/client";

export const handleUserCreated = async (
  c: AppContext,
  data: ClerkUserCreated
): Promise<ReturnType<typeof success> | ReturnType<typeof failure>> => {
  const supabase = c.get("supabase");
  const logger = c.get("logger");

  const email = (data as any).email_addresses[0]?.email_address;

  if (!email) {
    return failure(400, authErrorCodes.EMAIL_MISSING, "이메일이 없습니다.");
  }

  try {
    const { data: user, error: userError } = await supabase
      .from("users")
      .insert({
        clerk_user_id: (data as any).id,
        email,
      })
      .select()
      .single();

    if (userError) {
      logger.error("User creation failed", userError);
      return failure(500, authErrorCodes.USER_CREATE_FAILED, "사용자 생성 실패");
    }

    const { error: subError } = await supabase.from("subscriptions").insert({
      user_id: user.id,
      plan: "free",
      remaining_tests: 3,
    });

    if (subError) {
      logger.error("Subscription creation failed", subError);
      await supabase.from("users").delete().eq("id", user.id);
      return failure(500, authErrorCodes.SUB_CREATE_FAILED, "구독 생성 실패");
    }

    logger.info("User created successfully", { user_id: user.id });

    return success({ user_id: user.id });
  } catch (error) {
    logger.error("Unexpected error", error);
    return failure(500, authErrorCodes.INTERNAL_ERROR, "서버 오류");
  }
};

export const handleUserDeleted = async (
  c: AppContext,
  data: ClerkUserDeleted
): Promise<ReturnType<typeof success> | ReturnType<typeof failure>> => {
  const supabase = c.get("supabase");
  const logger = c.get("logger");

  try {
    const { data: user } = await supabase
      .from("users")
      .select(
        `
        id,
        subscriptions (
          billing_key
        )
      `
      )
      .eq("clerk_user_id", (data as any).id)
      .single();

    const subscriptionData = user?.subscriptions as unknown;
    const billingKeyData = Array.isArray(subscriptionData)
      ? subscriptionData[0]
      : subscriptionData;

    if (
      billingKeyData &&
      typeof billingKeyData === "object" &&
      "billing_key" in billingKeyData &&
      billingKeyData.billing_key
    ) {
      const deleted = await deleteTossBillingKey(
        billingKeyData.billing_key as string
      );
      if (!deleted) {
        logger.warn("Billing key deletion failed (continuing)", {
          user_id: user?.id,
        });
      }
    }

    const { error } = await supabase
      .from("users")
      .delete()
      .eq("clerk_user_id", (data as any).id);

    if (error) {
      logger.error("User deletion failed", error);
      return failure(500, authErrorCodes.USER_DELETE_FAILED, "사용자 삭제 실패");
    }

    logger.info("User deleted successfully", { clerk_user_id: (data as any).id });

    return success({ message: "User deleted" });
  } catch (error) {
    logger.error("Unexpected error", error);
    return failure(500, authErrorCodes.INTERNAL_ERROR, "서버 오류");
  }
};
</file>

<file path="src/features/auth/context/current-user-context.tsx">
"use client";

import {
  createContext,
  useContext,
  useMemo,
  type ReactNode,
} from "react";
import { useUser } from "@clerk/nextjs";

type CurrentUser = {
  id: string;
  clerkUserId: string;
  email: string | null;
  firstName: string | null;
  lastName: string | null;
  imageUrl: string | null;
};

type CurrentUserContextValue = {
  user: CurrentUser | null;
  status: "loading" | "authenticated" | "unauthenticated";
  isAuthenticated: boolean;
  isLoading: boolean;
};

const CurrentUserContext = createContext<CurrentUserContextValue | null>(null);

type CurrentUserProviderProps = {
  children: ReactNode;
};

export const CurrentUserProvider = ({ children }: CurrentUserProviderProps) => {
  const { user, isLoaded, isSignedIn } = useUser();

  const value = useMemo<CurrentUserContextValue>(() => {
    if (!isLoaded) {
      return {
        user: null,
        status: "loading",
        isAuthenticated: false,
        isLoading: true,
      };
    }

    if (!isSignedIn || !user) {
      return {
        user: null,
        status: "unauthenticated",
        isAuthenticated: false,
        isLoading: false,
      };
    }

    return {
      user: {
        id: user.id,
        clerkUserId: user.id,
        email: user.primaryEmailAddress?.emailAddress ?? null,
        firstName: user.firstName,
        lastName: user.lastName,
        imageUrl: user.imageUrl,
      },
      status: "authenticated",
      isAuthenticated: true,
      isLoading: false,
    };
  }, [isLoaded, isSignedIn, user]);

  return (
    <CurrentUserContext.Provider value={value}>
      {children}
    </CurrentUserContext.Provider>
  );
};

export const useCurrentUserContext = () => {
  const value = useContext(CurrentUserContext);

  if (!value) {
    throw new Error("CurrentUserProvider가 트리 상단에 필요합니다.");
  }

  return value;
};
</file>

<file path="src/features/auth/hooks/useCurrentUser.ts">
"use client";

import { useMemo } from "react";
import { useCurrentUserContext } from "../context/current-user-context";

export const useCurrentUser = () => {
  const context = useCurrentUserContext();

  return useMemo(
    () => ({
      user: context.user,
      status: context.status,
      isAuthenticated: context.isAuthenticated,
      isLoading: context.isLoading,
    }),
    [context]
  );
};
</file>

<file path="src/features/cron/backend/service.ts">
import type { AppContext } from "@/backend/hono/context";
import { success, failure } from "@/backend/http/response";
import { chargeTossPayment, deleteTossBillingKey } from "@/lib/toss/client";
import { cronErrorCodes } from "./error";
import { format } from "date-fns";
import { toZonedTime } from "date-fns-tz";

const PRO_PRICE = 3900;
const TIMEZONE = "Asia/Seoul";

export const processDailyBilling = async (c: AppContext) => {
  const supabase = c.get("supabase");
  const logger = c.get("logger");

  try {
    const now = toZonedTime(new Date(), TIMEZONE);
    const today = format(now, "yyyy-MM-dd");

    const { data: subscriptions, error: queryError } = await supabase
      .from("subscriptions")
      .select(
        `
        id,
        user_id,
        billing_key,
        cancel_at_period_end,
        users!inner (
          email
        )
      `
      )
      .eq("next_billing_date", today)
      .eq("plan", "pro");

    if (queryError) {
      logger.error("Failed to query subscriptions", queryError);
      return failure(500, cronErrorCodes.INTERNAL_ERROR, "구독 조회 실패");
    }

    if (!subscriptions || subscriptions.length === 0) {
      logger.info("No subscriptions to process today");
      return success({ processed: 0, success: 0, failed: 0 });
    }

    let successCount = 0;
    let failCount = 0;

    for (const subscription of subscriptions) {
      const userData = Array.isArray(subscription.users)
        ? subscription.users[0]
        : subscription.users;

      const userEmail =
        userData && typeof userData === "object" && "email" in userData
          ? (userData.email as string)
          : "";

      if (subscription.cancel_at_period_end) {
        if (subscription.billing_key) {
          await deleteTossBillingKey(subscription.billing_key);
        }

        await supabase
          .from("subscriptions")
          .update({
            plan: "free",
            billing_key: null,
            next_billing_date: null,
            remaining_tests: 0,
            cancel_at_period_end: false,
          })
          .eq("id", subscription.id);

        logger.info("Subscription expired", { subscription_id: subscription.id });
        continue;
      }

      if (!subscription.billing_key) {
        failCount++;
        continue;
      }

      const paymentResult = await chargeTossPayment({
        billing_key: subscription.billing_key,
        amount: PRO_PRICE,
        customer_email: userEmail,
      });

      if (paymentResult.success) {
        const nextBillingDate = toZonedTime(new Date(), TIMEZONE);
        nextBillingDate.setMonth(nextBillingDate.getMonth() + 1);

        await supabase
          .from("subscriptions")
          .update({
            remaining_tests: 10,
            next_billing_date: format(nextBillingDate, "yyyy-MM-dd"),
          })
          .eq("id", subscription.id);

        logger.info("Payment success", { subscription_id: subscription.id });
        successCount++;
      } else {
        await deleteTossBillingKey(subscription.billing_key);

        await supabase
          .from("subscriptions")
          .update({
            plan: "free",
            billing_key: null,
            next_billing_date: null,
            remaining_tests: 0,
          })
          .eq("id", subscription.id);

        logger.error("Payment failed", {
          subscription_id: subscription.id,
          error: paymentResult.error,
        });
        failCount++;
      }
    }

    logger.info("Daily billing completed", {
      total: subscriptions.length,
      success: successCount,
      failed: failCount,
    });

    return success({
      processed: subscriptions.length,
      success: successCount,
      failed: failCount,
    });
  } catch (error) {
    logger.error("Unexpected error in daily billing", error);
    return failure(500, cronErrorCodes.INTERNAL_ERROR, "서버 오류");
  }
};
</file>

<file path="src/features/payments/backend/service.ts">
import type { SupabaseClient } from "@supabase/supabase-js";
import type { HandlerResult } from "@/backend/http/response";
import { success, failure } from "@/backend/http/response";
import { paymentsErrorCodes, type PaymentsErrorCode } from "./error";
import type { ConfirmPaymentResponse } from "./schema";
import { addMonths, format } from "date-fns";
import { toZonedTime } from "date-fns-tz";

const SUBSCRIPTION_AMOUNT = 3900;
const PRO_MONTHLY_TESTS = 10;
const TIMEZONE = "Asia/Seoul";

type TossPaymentResponse = {
  paymentKey: string;
  orderId: string;
  status: string;
  totalAmount: number;
  method: string;
  requestedAt: string;
  approvedAt: string;
};

export async function confirmPayment(
  supabase: SupabaseClient,
  userId: string,
  paymentKey: string,
  orderId: string,
  amount: number
): Promise<HandlerResult<ConfirmPaymentResponse, PaymentsErrorCode>> {
  // 1. 금액 검증
  if (amount !== SUBSCRIPTION_AMOUNT) {
    return failure(
      400,
      paymentsErrorCodes.AMOUNT_MISMATCH,
      `결제 금액이 일치하지 않습니다. 예상: ${SUBSCRIPTION_AMOUNT}원, 받은: ${amount}원`
    );
  }

  // 2. 토스페이먼츠 결제 승인 API 호출
  const secretKey = process.env.TOSS_SECRET_KEY;
  if (!secretKey) {
    return failure(
      500,
      paymentsErrorCodes.INTERNAL_ERROR,
      "결제 설정이 올바르지 않습니다"
    );
  }

  const encodedKey = Buffer.from(`${secretKey}:`).toString("base64");

  try {
    const tossResponse = await fetch(
      "https://api.tosspayments.com/v1/payments/confirm",
      {
        method: "POST",
        headers: {
          Authorization: `Basic ${encodedKey}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ paymentKey, orderId, amount }),
      }
    );

    if (!tossResponse.ok) {
      const errorData = await tossResponse.json();
      return failure(
        400,
        paymentsErrorCodes.TOSS_API_ERROR,
        errorData.message || "결제 승인에 실패했습니다"
      );
    }

    const paymentData: TossPaymentResponse = await tossResponse.json();

    // 3. 결제 내역 저장
    const { error: paymentError } = await supabase.from("payments").insert({
      user_id: userId,
      payment_key: paymentKey,
      order_id: orderId,
      amount,
      status: paymentData.status,
      method: paymentData.method,
      approved_at: paymentData.approvedAt,
    });

    if (paymentError) {
      console.error("Failed to save payment record:", paymentError);
      // 결제는 성공했지만 기록 저장 실패 - 계속 진행
    }

    // 4. 구독 활성화 (기존 subscriptions 테이블 구조 사용)
    const now = toZonedTime(new Date(), TIMEZONE);
    const nextBillingDate = addMonths(now, 1);

    const { error: subscriptionError } = await supabase
      .from("subscriptions")
      .upsert(
        {
          user_id: userId,
          plan: "pro",
          status: "active",
          remaining_tests: PRO_MONTHLY_TESTS,
          next_billing_date: format(nextBillingDate, "yyyy-MM-dd"),
          current_period_start: now.toISOString(),
          current_period_end: nextBillingDate.toISOString(),
          cancel_at_period_end: false,
          updated_at: now.toISOString(),
        },
        {
          onConflict: "user_id",
        }
      );

    if (subscriptionError) {
      console.error("Failed to update subscription:", subscriptionError);
      return failure(
        500,
        paymentsErrorCodes.INTERNAL_ERROR,
        "구독 활성화에 실패했습니다"
      );
    }

    return success<ConfirmPaymentResponse>({
      success: true,
      paymentKey: paymentData.paymentKey,
      orderId: paymentData.orderId,
      status: paymentData.status,
    });
  } catch (error) {
    console.error("Payment confirmation error:", error);
    return failure(
      500,
      paymentsErrorCodes.INTERNAL_ERROR,
      "결제 처리 중 오류가 발생했습니다"
    );
  }
}
</file>

<file path="src/features/subscription/components/upgrade-prompt-card.tsx">
"use client";

import { useState } from "react";
import { Card, CardHeader, CardTitle, CardContent, CardFooter } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { useToast } from "@/hooks/use-toast";
import { PaymentDialog } from "./payment-dialog";
import { useAuth } from "@clerk/nextjs";

export function UpgradePromptCard() {
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const { toast } = useToast();
  const { userId } = useAuth();

  const handleOpenDialog = () => {
    setIsDialogOpen(true);
  };

  const handlePaymentSuccess = (billingKey: string) => {
    setIsDialogOpen(false);
    toast({
      title: "결제가 진행 중입니다",
      description: "결제 완료 후 구독이 활성화됩니다.",
    });
  };

  const handlePaymentError = (error: Error) => {
    toast({
      title: "결제에 실패했습니다",
      description: error.message || "결제 수단을 확인해주세요.",
      variant: "destructive",
    });
  };

  const customerKey = userId ? `customer_${userId}` : `customer_${Date.now()}`;

  return (
    <>
      <Card className="border-blue-200 bg-blue-50">
        <CardHeader>
          <CardTitle className="text-blue-900">
            Pro 플랜으로 업그레이드하세요!
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-3">
          <p className="text-sm text-blue-800">
            더 많은 검사와 고품질 분석을 경험해보세요.
          </p>
          <ul className="space-y-1 text-sm text-blue-700">
            <li>✨ 월 10회 고품질 검사</li>
            <li>✨ Gemini 2.5 Pro 모델 사용</li>
            <li>✨ 더 상세한 분석 결과</li>
            <li>✨ 월 3,900원 자동 결제</li>
          </ul>
        </CardContent>
        <CardFooter>
          <Button
            onClick={handleOpenDialog}
            className="w-full"
          >
            지금 시작하기
          </Button>
        </CardFooter>
      </Card>

      <PaymentDialog
        open={isDialogOpen}
        onOpenChange={setIsDialogOpen}
        customerKey={customerKey}
        onSuccess={handlePaymentSuccess}
        onError={handlePaymentError}
      />
    </>
  );
}
</file>

<file path="src/features/test/backend/error.ts">
export const testErrorCodes = {
  INSUFFICIENT_TESTS: "INSUFFICIENT_TESTS",
  TEST_CREATE_FAILED: "TEST_CREATE_FAILED",
  GEMINI_API_FAILED: "GEMINI_API_FAILED",
  TEST_NOT_FOUND: "TEST_NOT_FOUND",
  TEST_LIST_FAILED: "TEST_LIST_FAILED",
  ANALYSIS_ALREADY_EXISTS: "ANALYSIS_ALREADY_EXISTS",
  STREAM_FAILED: "STREAM_FAILED",
  INTERNAL_ERROR: "INTERNAL_ERROR",
} as const;

export type TestErrorCode = (typeof testErrorCodes)[keyof typeof testErrorCodes];
</file>

<file path="src/features/test/components/birth-date-picker.tsx">
"use client";

import { useState, useEffect } from "react";
import { format, getYear, parse, isValid } from "date-fns";
import { ko } from "date-fns/locale";
import { Calendar as CalendarIcon } from "lucide-react";
import { Calendar } from "@/components/ui/calendar";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { cn } from "@/lib/utils";

interface BirthDatePickerProps {
  value?: Date;
  onChange: (date: Date | undefined) => void;
}

const currentYear = getYear(new Date());

export const BirthDatePicker = ({ value, onChange }: BirthDatePickerProps) => {
  const [inputValue, setInputValue] = useState("");
  const [isOpen, setIsOpen] = useState(false);

  useEffect(() => {
    if (value) {
      setInputValue(format(value, "yyyy-MM-dd"));
    }
  }, [value]);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = e.target.value;
    setInputValue(newValue);

    if (newValue.length === 10) {
      const parsedDate = parse(newValue, "yyyy-MM-dd", new Date());
      if (isValid(parsedDate) && parsedDate <= new Date() && parsedDate >= new Date("1900-01-01")) {
        onChange(parsedDate);
      }
    }
  };

  const handleCalendarSelect = (date: Date | undefined) => {
    onChange(date);
    if (date) {
      setInputValue(format(date, "yyyy-MM-dd"));
    }
    setIsOpen(false);
  };

  return (
    <div className="flex gap-2">
      <Input
        type="text"
        placeholder="YYYY-MM-DD"
        value={inputValue}
        onChange={handleInputChange}
        className="flex-1"
      />
      <Popover open={isOpen} onOpenChange={setIsOpen}>
        <PopoverTrigger asChild>
          <Button
            variant="outline"
            size="icon"
            className={cn(!value && "text-muted-foreground")}
          >
            <CalendarIcon className="h-4 w-4" />
          </Button>
        </PopoverTrigger>
        <PopoverContent className="w-auto p-0" align="end">
          <Calendar
            mode="single"
            selected={value}
            onSelect={handleCalendarSelect}
            captionLayout="dropdown"
            fromYear={1900}
            toYear={currentYear}
            defaultMonth={value ?? new Date(1990, 0, 1)}
            disabled={(date) =>
              date > new Date() || date < new Date("1900-01-01")
            }
            locale={ko}
            initialFocus
          />
        </PopoverContent>
      </Popover>
    </div>
  );
};
</file>

<file path="src/features/test/components/test-card.tsx">
"use client";

import { useRouter } from "next/navigation";
import {
  Card,
  CardHeader,
  CardContent,
  CardFooter,
} from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Calendar, Clock, User, Trash2, AlertCircle } from "lucide-react";
import type { TestListResponse } from "../lib/dto";
import { format } from "date-fns";
import { ko } from "date-fns/locale";
import { useDeleteTest } from "../hooks/useDeleteTest";

type TestCardProps = {
  test: TestListResponse["tests"][number];
};

export const TestCard = ({ test }: TestCardProps) => {
  const router = useRouter();
  const { mutate: deleteTest, isPending: isDeleting } = useDeleteTest();

  const handleClick = () => {
    router.push(`/analysis/${test.id}`);
  };

  const handleDelete = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (confirm("이 검사를 삭제하시겠습니까?")) {
      deleteTest(test.id);
    }
  };

  const birthDate = format(new Date(test.birth_date), "yyyy년 MM월 dd일");
  const createdAt = format(
    new Date(test.created_at),
    "yyyy.MM.dd HH:mm",
    { locale: ko }
  );

  return (
    <Card
      className="cursor-pointer transition-all hover:shadow-lg hover:scale-[1.02] relative"
      onClick={handleClick}
    >
      <CardHeader>
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            <User className="h-4 w-4 text-muted-foreground" />
            <h3 className="text-lg font-semibold">{test.name}</h3>
          </div>
          <div className="flex items-center gap-2">
            {!test.has_analysis && (
              <Badge variant="destructive" className="gap-1">
                <AlertCircle className="h-3 w-3" />
                분석 실패
              </Badge>
            )}
            <Badge variant="outline">
              {test.gender === "male" ? "남성" : "여성"}
            </Badge>
          </div>
        </div>
      </CardHeader>

      <CardContent className="space-y-2">
        <div className="flex items-center gap-2 text-sm text-muted-foreground">
          <Calendar className="h-4 w-4" />
          <span>{birthDate}</span>
        </div>

        {test.birth_time && (
          <div className="flex items-center gap-2 text-sm text-muted-foreground">
            <Clock className="h-4 w-4" />
            <span>{test.birth_time.slice(0, 5)}</span>
          </div>
        )}
      </CardContent>

      <CardFooter className="justify-between">
        <span className="text-xs text-muted-foreground">
          검사 일시: {createdAt}
        </span>
        {!test.has_analysis && (
          <Button
            variant="ghost"
            size="sm"
            onClick={handleDelete}
            disabled={isDeleting}
            className="text-destructive hover:text-destructive hover:bg-destructive/10"
          >
            <Trash2 className="h-4 w-4" />
          </Button>
        )}
      </CardFooter>
    </Card>
  );
};
</file>

<file path="src/features/test/hooks/useStreamAnalysis.ts">
"use client";

import { useState, useCallback, useRef, useEffect } from "react";
import { useAuth } from "@clerk/nextjs";

type StreamStatus = "idle" | "streaming" | "completed" | "error";

interface UseStreamAnalysisReturn {
  streamedText: string;
  status: StreamStatus;
  error: string | null;
  fallbackMessage: string | null;
  startStream: (testId: string, model: string) => Promise<void>;
}

export const useStreamAnalysis = (): UseStreamAnalysisReturn => {
  const { getToken } = useAuth();
  const [streamedText, setStreamedText] = useState("");
  const [status, setStatus] = useState<StreamStatus>("idle");
  const [error, setError] = useState<string | null>(null);
  const [fallbackMessage, setFallbackMessage] = useState<string | null>(null);
  const abortControllerRef = useRef<AbortController | null>(null);

  useEffect(() => {
    return () => {
      if (abortControllerRef.current) {
        abortControllerRef.current.abort();
      }
    };
  }, []);

  const startStream = useCallback(
    async (testId: string, model: string) => {
      if (status === "streaming") return;

      setStreamedText("");
      setError(null);
      setFallbackMessage(null);
      setStatus("streaming");

      abortControllerRef.current = new AbortController();

      try {
        const token = await getToken();

        const response = await fetch(`/api/test/stream/${testId}`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify({ model }),
          signal: abortControllerRef.current.signal,
        });

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.message || "스트리밍 시작 실패");
        }

        const reader = response.body?.getReader();
        if (!reader) {
          throw new Error("스트림을 읽을 수 없습니다");
        }

        const decoder = new TextDecoder();

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          const chunk = decoder.decode(value, { stream: true });
          const lines = chunk.split("\n");

          for (const line of lines) {
            if (line.startsWith("data: ")) {
              const jsonStr = line.slice(6);
              if (jsonStr.trim()) {
                try {
                  const data = JSON.parse(jsonStr);

                  if (data.text) {
                    setStreamedText((prev) => prev + data.text);
                  }

                  if (data.fallback) {
                    setFallbackMessage(data.message);
                    setStreamedText("");
                  }

                  if (data.done) {
                    setStatus("completed");
                  }

                  if (data.error) {
                    setError(data.error);
                    setStatus("error");
                  }
                } catch (e) {
                  console.error("JSON parse error:", e);
                }
              }
            }
          }
        }

        if (status !== "error") {
          setStatus("completed");
        }
      } catch (err: any) {
        if (err.name === "AbortError") {
          return;
        }
        console.error("Stream error:", err);
        setError(err.message || "스트리밍 중 오류가 발생했습니다");
        setStatus("error");
      }
    },
    [getToken, status]
  );

  return {
    streamedText,
    status,
    error,
    fallbackMessage,
    startStream,
  };
};
</file>

<file path="src/features/test/lib/dto.ts">
export {
  createTestRequestSchema,
  createTestResponseSchema,
  initTestResponseSchema,
  testListResponseSchema,
  testDetailResponseSchema,
  type CreateTestRequest,
  type CreateTestResponse,
  type InitTestResponse,
  type TestListResponse,
  type TestDetailResponse,
} from "../backend/schema";
</file>

<file path="src/lib/remote/api-client.ts">
import axios, { isAxiosError } from "axios";

const apiClient = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_BASE_URL ?? "",
  headers: {
    "Content-Type": "application/json",
  },
  withCredentials: true,
});

type ErrorPayload = {
  error?: {
    message?: string;
  };
  message?: string;
};

export const extractApiErrorMessage = (
  error: unknown,
  fallbackMessage = "API request failed."
) => {
  if (isAxiosError(error)) {
    const payload = error.response?.data as ErrorPayload | undefined;

    if (typeof payload?.error?.message === "string") {
      return payload.error.message;
    }

    if (typeof payload?.message === "string") {
      return payload.message;
    }
  }

  if (error instanceof Error && error.message) {
    return error.message;
  }

  return fallbackMessage;
};

export { apiClient, isAxiosError };
</file>

<file path="src/lib/toss/sdk.ts">
"use client";

import { loadTossPayments } from "@tosspayments/tosspayments-sdk";
import type { RequestBillingKeyParams } from "./types";

export const initTossPayments = async () => {
  const clientKey = process.env.NEXT_PUBLIC_TOSS_CLIENT_KEY;

  if (!clientKey) {
    throw new Error("NEXT_PUBLIC_TOSS_CLIENT_KEY is not defined");
  }

  return await loadTossPayments(clientKey);
};

export const requestBillingKey = async (params: RequestBillingKeyParams) => {
  const tossPayments = await initTossPayments();

  return await (tossPayments as any).requestBillingAuth("카드", {
    customerKey: params.customerKey,
    successUrl: params.successUrl,
    failUrl: params.failUrl,
  });
};
</file>

<file path="src/app/(protected)/analysis/[id]/page.tsx">
"use client";

import { use } from "react";
import { useTestDetail } from "@/features/test/hooks/useTestDetail";
import { TestInfoCard } from "@/features/test/components/test-info-card";
import { AnalysisResultSection } from "@/features/test/components/analysis-result-section";
import { AnalysisActionButtons } from "@/features/test/components/analysis-action-buttons";
import { AnalysisSkeleton } from "@/features/test/components/analysis-skeleton";
import { Button } from "@/components/ui/button";
import { AlertCircle, Home } from "lucide-react";
import { useRouter } from "next/navigation";

interface PageProps {
  params: Promise<{ id: string }>;
}

export default function AnalysisDetailPage({ params }: PageProps) {
  const { id } = use(params);
  const router = useRouter();

  const { data: test, isLoading, error } = useTestDetail(id);

  if (isLoading) {
    return <AnalysisSkeleton />;
  }

  if (error) {
    const errorStatus = (error as { response?: { status?: number } })?.response
      ?.status;
    const errorMessage =
      errorStatus === 404
        ? "검사를 찾을 수 없습니다"
        : errorStatus === 403
          ? "접근 권한이 없습니다"
          : "오류가 발생했습니다. 다시 시도해주세요.";

    return (
      <div className="max-w-2xl mx-auto p-6">
        <div className="bg-white rounded-lg shadow-sm border p-8 text-center">
          <div className="flex justify-center mb-4">
            <AlertCircle className="w-16 h-16 text-red-500" />
          </div>
          <h1 className="text-2xl font-bold mb-2">{errorMessage}</h1>
          <p className="text-gray-600 mb-6">
            {errorStatus === 404 || errorStatus === 403
              ? "요청하신 검사 결과를 찾을 수 없거나 권한이 없습니다."
              : "일시적인 문제가 발생했습니다. 잠시 후 다시 시도해주세요."}
          </p>
          <Button onClick={() => router.push("/dashboard")} className="gap-2">
            <Home className="w-4 h-4" />
            대시보드로 돌아가기
          </Button>
        </div>
      </div>
    );
  }

  return (
    <div className="max-w-4xl mx-auto p-6">
      {test && <TestInfoCard test={test} />}
      {test && <AnalysisResultSection result={test.analysis_result || ""} />}
      <AnalysisActionButtons />
    </div>
  );
}
</file>

<file path="src/app/sign-in/[[...sign-in]]/page.tsx">
"use client";

import { useEffect } from "react";
import { useRouter } from "next/navigation";
import { SignIn, useUser } from "@clerk/nextjs";

type SignInPageProps = {
  params: Promise<Record<string, never>>;
};

export default function SignInPage({ params }: SignInPageProps) {
  void params;
  const { isSignedIn, isLoaded } = useUser();
  const router = useRouter();

  useEffect(() => {
    if (isLoaded && isSignedIn) {
      router.replace("/dashboard");
    }
  }, [isLoaded, isSignedIn, router]);

  if (!isLoaded) {
    return null;
  }

  if (isSignedIn) {
    return null;
  }

  return (
    <div className="flex min-h-screen items-center justify-center bg-slate-50">
      <SignIn
        appearance={{
          elements: {
            rootBox: "mx-auto",
            card: "shadow-xl",
          },
        }}
        routing="path"
        path="/sign-in"
        signUpUrl="/sign-up"
        fallbackRedirectUrl="/dashboard"
      />
    </div>
  );
}
</file>

<file path="src/features/subscription/backend/route.ts">
import type { Hono } from "hono";
import { zValidator } from "@hono/zod-validator";
import { getAuth } from "@hono/clerk-auth";
import type { AppEnv } from "@/backend/hono/context";
import { respond, failure } from "@/backend/http/response";
import { createSubscriptionRequestSchema } from "./schema";
import {
  getSubscriptionStatus,
  createProSubscription,
  cancelSubscription,
  reactivateSubscription,
} from "./service";
import { subscriptionErrorCodes } from "./error";
import { getOrCreateUser } from "@/features/auth/backend/helpers";

export const registerSubscriptionRoutes = (app: Hono<AppEnv>) => {
  app.get("/api/subscription/status", async (c) => {
    const auth = getAuth(c);

    if (!auth?.userId) {
      return respond(
        c,
        failure(401, subscriptionErrorCodes.INTERNAL_ERROR, "인증이 필요합니다")
      );
    }

    const supabase = c.get("supabase");
    const logger = c.get("logger");
    const userResult = await getOrCreateUser(supabase, logger, auth.userId);

    if (!userResult.success) {
      return respond(
        c,
        failure(404, subscriptionErrorCodes.INTERNAL_ERROR, userResult.error)
      );
    }

    return respond(c, await getSubscriptionStatus(supabase, userResult.user.id));
  });

  app.post(
    "/api/subscription/create",
    zValidator("json", createSubscriptionRequestSchema) as never,
    async (c) => {
      const auth = getAuth(c);

      if (!auth?.userId) {
        return respond(
          c,
          failure(401, subscriptionErrorCodes.INTERNAL_ERROR, "인증이 필요합니다")
        );
      }

      const supabase = c.get("supabase");
      const logger = c.get("logger");
      const userResult = await getOrCreateUser(supabase, logger, auth.userId);

      if (!userResult.success) {
        return respond(
          c,
          failure(404, subscriptionErrorCodes.INTERNAL_ERROR, userResult.error)
        );
      }

      const body = await c.req.json();
      const parsed = createSubscriptionRequestSchema.parse(body);

      return respond(
        c,
        await createProSubscription(c, userResult.user.id, userResult.user.email, parsed)
      );
    }
  );

  app.post("/api/subscription/cancel", async (c) => {
    const auth = getAuth(c);

    if (!auth?.userId) {
      return respond(
        c,
        failure(401, subscriptionErrorCodes.INTERNAL_ERROR, "인증이 필요합니다")
      );
    }

    const supabase = c.get("supabase");
    const logger = c.get("logger");
    const userResult = await getOrCreateUser(supabase, logger, auth.userId);

    if (!userResult.success) {
      return respond(
        c,
        failure(404, subscriptionErrorCodes.INTERNAL_ERROR, userResult.error)
      );
    }

    return respond(c, await cancelSubscription(supabase, userResult.user.id));
  });

  app.post("/api/subscription/reactivate", async (c) => {
    const auth = getAuth(c);

    if (!auth?.userId) {
      return respond(
        c,
        failure(401, subscriptionErrorCodes.INTERNAL_ERROR, "인증이 필요합니다")
      );
    }

    const supabase = c.get("supabase");
    const logger = c.get("logger");
    const userResult = await getOrCreateUser(supabase, logger, auth.userId);

    if (!userResult.success) {
      return respond(
        c,
        failure(404, subscriptionErrorCodes.INTERNAL_ERROR, userResult.error)
      );
    }

    return respond(c, await reactivateSubscription(supabase, userResult.user.id));
  });
};
</file>

<file path="src/features/subscription/components/payment-dialog.tsx">
"use client";

import { useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Loader2, CreditCard, Shield, CheckCircle } from "lucide-react";
import { loadTossPayments } from "@tosspayments/tosspayments-sdk";

type PaymentDialogProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  customerKey: string;
  onSuccess: (billingKey: string) => void;
  onError: (error: Error) => void;
};

const SUBSCRIPTION_AMOUNT = 3900;
const SUBSCRIPTION_ORDER_NAME = "사주포춘 Pro 월간 구독";

export function PaymentDialog({
  open,
  onOpenChange,
  customerKey,
  onError,
}: PaymentDialogProps) {
  const [isProcessing, setIsProcessing] = useState(false);

  const handlePayment = async () => {
    setIsProcessing(true);

    try {
      const clientKey = process.env.NEXT_PUBLIC_TOSS_CLIENT_KEY;
      if (!clientKey) {
        throw new Error("NEXT_PUBLIC_TOSS_CLIENT_KEY is not defined");
      }

      const tossPayments = await loadTossPayments(clientKey);
      const orderId = `ORDER_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;

      // 결제창 객체 생성 후 결제 요청
      const payment = tossPayments.payment({ customerKey });

      await payment.requestPayment({
        method: "CARD",
        amount: {
          currency: "KRW",
          value: SUBSCRIPTION_AMOUNT,
        },
        orderId,
        orderName: SUBSCRIPTION_ORDER_NAME,
        successUrl: `${window.location.origin}/subscription/success`,
        failUrl: `${window.location.origin}/subscription/fail`,
      });
    } catch (error) {
      console.error("Payment request failed:", error);
      setIsProcessing(false);
      onError(error instanceof Error ? error : new Error("결제 요청 실패"));
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[450px]">
        <DialogHeader>
          <DialogTitle className="text-xl">Pro 구독 결제</DialogTitle>
          <DialogDescription>
            월 {SUBSCRIPTION_AMOUNT.toLocaleString()}원으로 Pro 플랜의 모든 혜택을 이용하세요.
          </DialogDescription>
        </DialogHeader>

        <div className="py-4 space-y-4">
          {/* 구독 혜택 안내 */}
          <div className="p-4 bg-blue-50 rounded-lg border border-blue-100">
            <h3 className="font-semibold text-blue-900 mb-3 flex items-center gap-2">
              <CheckCircle className="h-5 w-5" />
              Pro 플랜 혜택
            </h3>
            <ul className="text-sm text-blue-700 space-y-2">
              <li className="flex items-center gap-2">
                <span className="text-blue-500">✓</span>
                월 10회 고품질 검사
              </li>
              <li className="flex items-center gap-2">
                <span className="text-blue-500">✓</span>
                Gemini 2.5 Pro 모델 사용
              </li>
              <li className="flex items-center gap-2">
                <span className="text-blue-500">✓</span>
                더 상세한 분석 결과
              </li>
            </ul>
          </div>

          {/* 결제 금액 표시 */}
          <div className="p-4 bg-gray-50 rounded-lg border">
            <div className="flex justify-between items-center">
              <span className="text-gray-600">월 구독료</span>
              <span className="text-2xl font-bold text-gray-900">
                {SUBSCRIPTION_AMOUNT.toLocaleString()}원
              </span>
            </div>
            <p className="text-xs text-gray-500 mt-2">
              매월 자동 결제됩니다. 언제든지 취소할 수 있습니다.
            </p>
          </div>

          {/* 안전 결제 안내 */}
          <div className="flex items-center gap-2 text-sm text-gray-500">
            <Shield className="h-4 w-4" />
            <span>토스페이먼츠 안전결제</span>
          </div>
        </div>

        {/* 결제 버튼 */}
        <Button
          onClick={handlePayment}
          disabled={isProcessing}
          className="w-full"
          size="lg"
        >
          {isProcessing ? (
            <>
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              결제 페이지로 이동 중...
            </>
          ) : (
            <>
              <CreditCard className="mr-2 h-4 w-4" />
              {SUBSCRIPTION_AMOUNT.toLocaleString()}원 결제하기
            </>
          )}
        </Button>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/lib/gemini/client.ts">
import { google } from "@ai-sdk/google";
import { generateText, streamText } from "ai";
import { generateSajuPrompt } from "./prompt";
import type { GeminiModel, SajuInput } from "./types";

export const generateSajuAnalysis = async (
  input: SajuInput,
  model: GeminiModel
): Promise<string | null> => {
  try {
    const prompt = generateSajuPrompt(input);

    const { text } = await generateText({
      model: google(model),
      prompt,
      temperature: 0.7,
    });

    return text;
  } catch (error) {
    console.error("Gemini API error", error);
    return null;
  }
};

export const streamSajuAnalysis = async (
  input: SajuInput,
  model: GeminiModel
) => {
  const prompt = generateSajuPrompt(input);

  const result = streamText({
    model: google(model),
    prompt,
    temperature: 0.7,
  });

  return result;
};
</file>

<file path="src/lib/gemini/types.ts">
export type GeminiModel = "gemini-2.0-flash";

export type SajuInput = {
  name: string;
  birth_date: string;
  birth_time: string | null;
  gender: "male" | "female";
};

export type GeminiError = {
  message: string;
  code?: string;
};
</file>

<file path="src/app/(protected)/layout.tsx">
"use client";

import { type ReactNode } from "react";
import { useUser, RedirectToSignIn } from "@clerk/nextjs";
import { GlobalNav } from "@/components/layout/global-nav";

type ProtectedLayoutProps = {
  children: ReactNode;
};

export default function ProtectedLayout({ children }: ProtectedLayoutProps) {
  const { isLoaded, isSignedIn } = useUser();

  if (!isLoaded) {
    return (
      <div className="flex min-h-screen items-center justify-center">
        <div className="h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent" />
      </div>
    );
  }

  if (!isSignedIn) {
    return <RedirectToSignIn />;
  }

  return (
    <div className="flex min-h-screen">
      <aside className="fixed inset-y-0 left-0 z-40 w-64 border-r bg-background">
        <GlobalNav />
      </aside>
      <main className="flex-1 pl-64">
        {children}
      </main>
    </div>
  );
}
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import { ClerkProvider } from "@clerk/nextjs";
import "./globals.css";
import Providers from "./providers";
import { CurrentUserProvider } from "@/features/auth/context/current-user-context";

export const metadata: Metadata = {
  title: "Saju피아 - AI 기반 사주팔자 분석",
  description: "Google Gemini AI가 풀어주는 당신의 사주팔자. 무료 3회 체험, Pro 구독 시 월 10회 분석 제공.",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <ClerkProvider
      signInUrl="/sign-in"
      signUpUrl="/sign-up"
      signInFallbackRedirectUrl="/dashboard"
      signUpFallbackRedirectUrl="/dashboard"
    >
      <html lang="ko" suppressHydrationWarning data-scroll-behavior="smooth">
        <body className="antialiased font-sans">
          <Providers>
            <CurrentUserProvider>
              {children}
            </CurrentUserProvider>
          </Providers>
        </body>
      </html>
    </ClerkProvider>
  );
}
</file>

<file path="src/backend/hono/app.ts">
import { Hono } from 'hono';
import { clerkMiddleware } from '@hono/clerk-auth';
import { errorBoundary } from '@/backend/middleware/error';
import { withAppContext } from '@/backend/middleware/context';
import { withSupabase } from '@/backend/middleware/supabase';
import { registerExampleRoutes } from '@/features/example/backend/route';
import { registerAuthRoutes } from '@/features/auth/backend/route';
import { registerTestRoutes } from '@/features/test/backend/route';
import { registerSubscriptionRoutes } from '@/features/subscription/backend/route';
import { registerPaymentsRoutes } from '@/features/payments/backend/route';
import { registerCronRoutes } from '@/features/cron/backend/route';
import type { AppEnv } from '@/backend/hono/context';

let singletonApp: Hono<AppEnv> | null = null;

export const createHonoApp = () => {
  if (singletonApp && process.env.NODE_ENV === 'production') {
    return singletonApp;
  }

  const app = new Hono<AppEnv>();

  app.use('*', errorBoundary());
  app.use('*', withAppContext());
  app.use('*', clerkMiddleware({
    publishableKey: process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY,
    secretKey: process.env.CLERK_SECRET_KEY,
  }));
  app.use('*', withSupabase());

  registerExampleRoutes(app);
  registerAuthRoutes(app);
  registerTestRoutes(app);
  registerSubscriptionRoutes(app);
  registerPaymentsRoutes(app);
  registerCronRoutes(app);

  if (process.env.NODE_ENV === 'production') {
    singletonApp = app;
  }

  return app;
};
</file>

<file path="src/components/layout/nav-footer.tsx">
"use client";

import { useCurrentUser } from "@/features/auth/hooks/useCurrentUser";
import { useSubscription } from "@/features/subscription/hooks/useSubscription";
import { Button } from "@/components/ui/button";
import { Skeleton } from "@/components/ui/skeleton";
import { useRouter } from "next/navigation";
import { useClerk } from "@clerk/nextjs";
import { LogOut, Settings, User } from "lucide-react";

export function NavFooter() {
  const { user } = useCurrentUser();
  const { data: subscription, isLoading } = useSubscription();
  const router = useRouter();
  const { signOut, openUserProfile } = useClerk();

  const handleLogout = () => {
    signOut({ redirectUrl: "/" });
  };

  const handleManageAccount = () => {
    openUserProfile();
  };

  if (isLoading) {
    return (
      <div className="mt-auto p-4 space-y-3">
        <Skeleton className="h-4 w-full" />
        <Skeleton className="h-4 w-3/4" />
        <Skeleton className="h-8 w-full" />
      </div>
    );
  }

  if (!user || !subscription) {
    return null;
  }

  const maxTests = subscription.plan === "pro" ? 10 : 3;

  return (
    <div className="mt-auto">
      <div className="p-4 border-t space-y-2">
        <div className="text-sm font-medium">
          잔여 횟수: {subscription.remaining_tests}/{maxTests}
        </div>
        <Button
          variant={subscription.plan === "free" ? "outline" : "default"}
          size="sm"
          className="w-full"
          onClick={() => router.push("/subscription")}
        >
          {subscription.plan === "free" ? "Pro로 업그레이드" : "구독 관리"}
        </Button>
      </div>

      <div className="p-4 border-t space-y-1">
        <div className="flex items-center gap-2 text-sm text-muted-foreground pb-2">
          <User className="w-4 h-4" />
          <span className="truncate flex-1">{user.email}</span>
        </div>
        <Button
          variant="ghost"
          size="sm"
          className="w-full justify-start text-muted-foreground hover:text-foreground"
          onClick={handleManageAccount}
        >
          <Settings className="w-4 h-4 mr-2" />
          계정 관리
        </Button>
        <Button
          variant="ghost"
          size="sm"
          className="w-full justify-start text-muted-foreground hover:text-foreground"
          onClick={handleLogout}
        >
          <LogOut className="w-4 h-4 mr-2" />
          로그아웃
        </Button>
      </div>
    </div>
  );
}
</file>

<file path="src/features/test/backend/schema.ts">
import { z } from "zod";

export const createTestRequestSchema = z.object({
  name: z.string().min(1, "이름은 필수입니다"),
  birth_date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "날짜 형식이 올바르지 않습니다"),
  birth_time: z.string().nullable(),
  gender: z.enum(["male", "female"]),
});

export const testListQuerySchema = z.object({
  name: z.string().optional(),
  limit: z.coerce.number().int().positive().default(20),
  offset: z.coerce.number().int().min(0).default(0),
});

export const testParamsSchema = z.object({
  id: z.string().uuid(),
});

export const createTestResponseSchema = z.object({
  test_id: z.string().uuid(),
  analysis_result: z.string(),
});

export const initTestResponseSchema = z.object({
  test_id: z.string().uuid(),
  model: z.literal("gemini-2.0-flash"),
});

export const testListItemSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  birth_date: z.string(),
  birth_time: z.string().nullable(),
  gender: z.enum(["male", "female"]),
  created_at: z.string(),
  has_analysis: z.boolean(),
});

export const testListResponseSchema = z.object({
  tests: z.array(testListItemSchema),
  total: z.number(),
});

export const testDetailResponseSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  birth_date: z.string(),
  birth_time: z.string().nullable(),
  gender: z.enum(["male", "female"]),
  analysis_result: z.string().nullable(),
  created_at: z.string(),
});

export type CreateTestRequest = z.infer<typeof createTestRequestSchema>;
export type TestListQuery = z.infer<typeof testListQuerySchema>;
export type CreateTestResponse = z.infer<typeof createTestResponseSchema>;
export type InitTestResponse = z.infer<typeof initTestResponseSchema>;
export type TestListResponse = z.infer<typeof testListResponseSchema>;
export type TestDetailResponse = z.infer<typeof testDetailResponseSchema>;
</file>

<file path="src/features/test/components/new-test-form.tsx">
"use client";

import { useState, useEffect } from "react";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { format } from "date-fns";
import { Loader2 } from "lucide-react";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import { BirthDatePicker } from "./birth-date-picker";
import { BirthTimePicker } from "./birth-time-picker";
import { GenderSelector } from "./gender-selector";
import { TestResultDialog } from "./test-result-dialog";
import { StreamingDialog } from "./streaming-dialog";
import { useInitTest } from "../hooks/useInitTest";
import { useStreamAnalysis } from "../hooks/useStreamAnalysis";

const formSchema = z.object({
  name: z
    .string()
    .min(1, "이름을 입력해주세요")
    .max(50, "이름은 50자 이내로 입력해주세요"),
  birth_date: z.date({ required_error: "생년월일을 선택해주세요" }),
  birth_time: z.string().nullable(),
  birth_time_unknown: z.boolean().default(false),
  gender: z.enum(["male", "female"], {
    required_error: "성별을 선택해주세요",
  }),
});

type FormData = z.infer<typeof formSchema>;

type DialogResult = {
  type: "success" | "error" | "quota_exceeded";
  testId?: string;
  errorMessage?: string;
  errorCode?: string;
} | null;

export const NewTestForm = () => {
  const router = useRouter();
  const [dialogOpen, setDialogOpen] = useState(false);
  const [dialogResult, setDialogResult] = useState<DialogResult>(null);
  const [streamingDialogOpen, setStreamingDialogOpen] = useState(false);
  const [currentTestId, setCurrentTestId] = useState<string | null>(null);

  const { mutate: initTest, isPending } = useInitTest();
  const { streamedText, status, error: streamError, fallbackMessage, startStream } = useStreamAnalysis();

  const form = useForm<FormData>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      name: "",
      birth_date: undefined,
      birth_time: "12:00",
      birth_time_unknown: false,
      gender: undefined,
    },
  });

  const birthTimeUnknown = form.watch("birth_time_unknown");

  useEffect(() => {
    if (status === "completed" && currentTestId) {
      const timer = setTimeout(() => {
        setStreamingDialogOpen(false);
        router.push(`/analysis/${currentTestId}`);
      }, 1500);
      return () => clearTimeout(timer);
    }
  }, [status, currentTestId, router]);

  useEffect(() => {
    if (status === "error" && streamError) {
      const timer = setTimeout(() => {
        setStreamingDialogOpen(false);
        setDialogResult({
          type: "error",
          errorMessage: streamError,
        });
        setDialogOpen(true);
      }, 3000);
      return () => clearTimeout(timer);
    }
  }, [status, streamError]);

  const onSubmit = (data: FormData) => {
    const requestData = {
      name: data.name,
      birth_date: format(data.birth_date, "yyyy-MM-dd"),
      birth_time: data.birth_time_unknown ? null : data.birth_time,
      gender: data.gender,
    };

    initTest(requestData, {
      onSuccess: (response) => {
        setCurrentTestId(response.test_id);
        setStreamingDialogOpen(true);
        startStream(response.test_id, response.model);
      },
      onError: (error: any) => {
        const message =
          error.response?.data?.message || "검사 생성에 실패했습니다";
        const errorCode = error.response?.data?.errorCode;

        if (error.response?.status === 403) {
          setDialogResult({
            type: "quota_exceeded",
          });
        } else {
          setDialogResult({
            type: "error",
            errorMessage: message,
            errorCode: errorCode,
          });
        }
        setDialogOpen(true);
      },
    });
  };

  const isStreaming = status === "streaming" || status === "idle";

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>이름</FormLabel>
              <FormControl>
                <Input placeholder="예) 홍길동" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="birth_date"
          render={({ field }) => (
            <FormItem>
              <FormLabel>생년월일</FormLabel>
              <FormControl>
                <BirthDatePicker value={field.value} onChange={field.onChange} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="birth_time"
          render={({ field }) => (
            <FormItem>
              <FormLabel>출생시간</FormLabel>
              <FormControl>
                <BirthTimePicker
                  value={field.value || "12:00"}
                  onChange={field.onChange}
                  disabled={birthTimeUnknown}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="birth_time_unknown"
          render={({ field }) => (
            <FormItem className="flex flex-row items-start space-x-3 space-y-0">
              <FormControl>
                <Checkbox
                  checked={field.value}
                  onCheckedChange={field.onChange}
                />
              </FormControl>
              <div className="space-y-1 leading-none">
                <FormLabel>출생시간 모름</FormLabel>
              </div>
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name="gender"
          render={({ field }) => (
            <FormItem>
              <FormLabel>성별</FormLabel>
              <FormControl>
                <GenderSelector value={field.value} onChange={field.onChange} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <Button type="submit" className="w-full" disabled={isPending || streamingDialogOpen}>
          {isPending ? (
            <>
              <Loader2 className="mr-2 h-4 w-4 animate-spin" />
              검사를 준비하고 있습니다...
            </>
          ) : (
            "검사 시작"
          )}
        </Button>
      </form>

      <TestResultDialog
        open={dialogOpen}
        onOpenChange={setDialogOpen}
        result={dialogResult}
      />

      <StreamingDialog
        open={streamingDialogOpen}
        streamedText={streamedText}
        isStreaming={isStreaming}
        fallbackMessage={fallbackMessage}
        error={streamError}
      />
    </Form>
  );
};
</file>

<file path="src/features/test/backend/service.ts">
import type { AppContext } from "@/backend/hono/context";
import { success, failure } from "@/backend/http/response";
import { generateSajuAnalysis } from "@/lib/gemini/client";
import type { GeminiModel } from "@/lib/gemini/types";
import type {
  CreateTestRequest,
  CreateTestResponse,
  InitTestResponse,
  TestListQuery,
  TestListResponse,
  TestDetailResponse,
} from "./schema";
import { testErrorCodes } from "./error";
import type { SupabaseClient } from "@supabase/supabase-js";

export const createTest = async (
  c: AppContext,
  userId: string,
  input: CreateTestRequest
) => {
  const supabase = c.get("supabase");
  const logger = c.get("logger");

  try {
    const { data: subscription, error: subError } = await supabase
      .from("subscriptions")
      .select("plan, remaining_tests")
      .eq("user_id", userId)
      .single();

    if (subError || !subscription) {
      logger.error("Subscription not found", subError);
      return failure(404, testErrorCodes.INTERNAL_ERROR, "구독 정보를 찾을 수 없습니다");
    }

    if (subscription.remaining_tests <= 0) {
      return failure(
        403,
        testErrorCodes.INSUFFICIENT_TESTS,
        "검사 횟수를 모두 사용했습니다"
      );
    }

    const { data: test, error: testError } = await supabase
      .from("tests")
      .insert({
        user_id: userId,
        name: input.name,
        birth_date: input.birth_date,
        birth_time: input.birth_time,
        gender: input.gender,
      })
      .select()
      .single();

    if (testError) {
      logger.error("Test creation failed", testError);
      return failure(500, testErrorCodes.TEST_CREATE_FAILED, "검사 생성 실패");
    }

    const model: GeminiModel = "gemini-2.0-flash";

    const analysisResult = await generateSajuAnalysis(
      {
        name: input.name,
        birth_date: input.birth_date,
        birth_time: input.birth_time,
        gender: input.gender,
      },
      model
    );

    if (!analysisResult) {
      await supabase.from("tests").delete().eq("id", test.id);
      return failure(500, testErrorCodes.GEMINI_API_FAILED, "AI 분석 실패");
    }

    const { error: updateError } = await supabase
      .from("tests")
      .update({ analysis_result: analysisResult })
      .eq("id", test.id);

    if (updateError) {
      logger.error("Test update failed", updateError);
    }

    const { error: decrementError } = await supabase
      .from("subscriptions")
      .update({ remaining_tests: subscription.remaining_tests - 1 })
      .eq("user_id", userId);

    if (decrementError) {
      logger.error("Failed to decrement remaining_tests", decrementError);
    }

    logger.info("Test created successfully", { test_id: test.id });

    const response: CreateTestResponse = {
      test_id: test.id,
      analysis_result: analysisResult,
    };

    return success(response);
  } catch (error) {
    logger.error("Unexpected error", error);
    return failure(500, testErrorCodes.INTERNAL_ERROR, "서버 오류");
  }
};

export const getTestList = async (
  supabase: SupabaseClient,
  userId: string,
  query: TestListQuery
) => {
  try {
    let queryBuilder = supabase
      .from("tests")
      .select("id, name, birth_date, birth_time, gender, created_at, analysis_result", {
        count: "exact",
      })
      .eq("user_id", userId)
      .order("created_at", { ascending: false });

    if (query.name) {
      queryBuilder = queryBuilder.ilike("name", `%${query.name}%`);
    }

    queryBuilder = queryBuilder.range(query.offset, query.offset + query.limit - 1);

    const { data, error, count } = await queryBuilder;

    if (error) {
      return failure(500, testErrorCodes.TEST_LIST_FAILED, "검사 목록 조회 실패");
    }

    const tests = (data || []).map((test: any) => ({
      id: test.id,
      name: test.name,
      birth_date: test.birth_date,
      birth_time: test.birth_time,
      gender: test.gender,
      created_at: test.created_at,
      has_analysis: !!test.analysis_result,
    }));

    const response: TestListResponse = {
      tests,
      total: count || 0,
    };

    return success(response);
  } catch (error) {
    return failure(500, testErrorCodes.INTERNAL_ERROR, "서버 오류");
  }
};

export const getTestDetail = async (
  supabase: SupabaseClient,
  userId: string,
  testId: string
) => {
  try {
    const { data, error } = await supabase
      .from("tests")
      .select("*")
      .eq("id", testId)
      .eq("user_id", userId)
      .single();

    if (error || !data) {
      return failure(404, testErrorCodes.TEST_NOT_FOUND, "검사를 찾을 수 없습니다");
    }

    const response: TestDetailResponse = {
      id: data.id,
      name: data.name,
      birth_date: data.birth_date,
      birth_time: data.birth_time,
      gender: data.gender,
      analysis_result: data.analysis_result,
      created_at: data.created_at,
    };

    return success(response);
  } catch (error) {
    return failure(500, testErrorCodes.INTERNAL_ERROR, "서버 오류");
  }
};

export const initTest = async (
  c: AppContext,
  userId: string,
  input: CreateTestRequest
) => {
  const supabase = c.get("supabase");
  const logger = c.get("logger");

  try {
    const { data: subscription, error: subError } = await supabase
      .from("subscriptions")
      .select("plan, remaining_tests")
      .eq("user_id", userId)
      .single();

    if (subError || !subscription) {
      logger.error("Subscription not found", subError);
      return failure(404, testErrorCodes.INTERNAL_ERROR, "구독 정보를 찾을 수 없습니다");
    }

    if (subscription.remaining_tests <= 0) {
      return failure(
        403,
        testErrorCodes.INSUFFICIENT_TESTS,
        "검사 횟수를 모두 사용했습니다"
      );
    }

    const { data: test, error: testError } = await supabase
      .from("tests")
      .insert({
        user_id: userId,
        name: input.name,
        birth_date: input.birth_date,
        birth_time: input.birth_time,
        gender: input.gender,
      })
      .select()
      .single();

    if (testError) {
      logger.error("Test creation failed", testError);
      return failure(500, testErrorCodes.TEST_CREATE_FAILED, "검사 생성 실패");
    }

    const { error: decrementError } = await supabase
      .from("subscriptions")
      .update({ remaining_tests: subscription.remaining_tests - 1 })
      .eq("user_id", userId);

    if (decrementError) {
      logger.error("Failed to decrement remaining_tests", decrementError);
    }

    const model: GeminiModel = "gemini-2.0-flash";

    logger.info("Test initialized", { test_id: test.id, model });

    const response: InitTestResponse = {
      test_id: test.id,
      model,
    };

    return success(response);
  } catch (error) {
    logger.error("Unexpected error", error);
    return failure(500, testErrorCodes.INTERNAL_ERROR, "서버 오류");
  }
};

export const getTestForStream = async (
  supabase: SupabaseClient,
  userId: string,
  testId: string
) => {
  try {
    const { data, error } = await supabase
      .from("tests")
      .select("id, name, birth_date, birth_time, gender, analysis_result")
      .eq("id", testId)
      .eq("user_id", userId)
      .single();

    if (error || !data) {
      return failure(404, testErrorCodes.TEST_NOT_FOUND, "검사를 찾을 수 없습니다");
    }

    if (data.analysis_result) {
      return failure(400, testErrorCodes.ANALYSIS_ALREADY_EXISTS, "이미 분석이 완료되었습니다");
    }

    return success(data);
  } catch (error) {
    return failure(500, testErrorCodes.INTERNAL_ERROR, "서버 오류");
  }
};

export const updateTestAnalysis = async (
  supabase: SupabaseClient,
  testId: string,
  analysisResult: string
) => {
  try {
    const { error } = await supabase
      .from("tests")
      .update({ analysis_result: analysisResult })
      .eq("id", testId);

    if (error) {
      return failure(500, testErrorCodes.INTERNAL_ERROR, "분석 결과 저장 실패");
    }

    return success({ updated: true });
  } catch (error) {
    return failure(500, testErrorCodes.INTERNAL_ERROR, "서버 오류");
  }
};

export const deleteTest = async (
  supabase: SupabaseClient,
  userId: string,
  testId: string
) => {
  try {
    const { data: test, error: selectError } = await supabase
      .from("tests")
      .select("id, user_id")
      .eq("id", testId)
      .eq("user_id", userId)
      .single();

    if (selectError || !test) {
      return failure(404, testErrorCodes.TEST_NOT_FOUND, "검사를 찾을 수 없습니다");
    }

    const { error: deleteError } = await supabase
      .from("tests")
      .delete()
      .eq("id", testId);

    if (deleteError) {
      return failure(500, testErrorCodes.INTERNAL_ERROR, "삭제 실패");
    }

    return success({ deleted: true });
  } catch (error) {
    return failure(500, testErrorCodes.INTERNAL_ERROR, "서버 오류");
  }
};
</file>

<file path="package.json">
{
  "name": "template",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@ai-sdk/google": "^2.0.46",
    "@ai-sdk/openai": "^2.0.86",
    "@clerk/nextjs": "^6.36.2",
    "@hono/clerk-auth": "^3.0.3",
    "@hono/zod-validator": "^0.7.5",
    "@hookform/resolvers": "^4",
    "@radix-ui/react-accordion": "^1.2.3",
    "@radix-ui/react-avatar": "^1.1.2",
    "@radix-ui/react-checkbox": "^1.1.1",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.1",
    "@radix-ui/react-label": "^2.1.0",
    "@radix-ui/react-popover": "^1.1.15",
    "@radix-ui/react-radio-group": "^1.3.8",
    "@radix-ui/react-scroll-area": "^1.2.10",
    "@radix-ui/react-select": "^2.1.4",
    "@radix-ui/react-separator": "^1.1.1",
    "@radix-ui/react-slot": "^1.2.4",
    "@radix-ui/react-toast": "^1.2.6",
    "@supabase/ssr": "^0.5.2",
    "@supabase/supabase-js": "^2.87.1",
    "@tanstack/react-query": "^5",
    "@tosspayments/tosspayments-sdk": "^2.5.0",
    "ai": "^5.0.112",
    "axios": "^1.7.9",
    "bcryptjs": "^3.0.3",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "date-fns-tz": "^3.2.0",
    "es-toolkit": "^1",
    "framer-motion": "^11",
    "hono": "^4.9.9",
    "lucide-react": "^0.469.0",
    "next": "^15.5.9",
    "next-themes": "^0.4.3",
    "react": "^19.0.0",
    "react-day-picker": "^9.12.0",
    "react-dom": "^19.0.0",
    "react-hook-form": "^7",
    "react-markdown": "^10.1.0",
    "react-use": "^17",
    "remark-gfm": "^4.0.1",
    "server-only": "0.0.1",
    "ts-pattern": "^5",
    "zod": "^3",
    "zustand": "^4"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4.1.13",
    "@tailwindcss/typography": "^0.5.10",
    "@types/bcryptjs": "^2.4.6",
    "@types/navermaps": "^3.9.1",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.1.0",
    "postcss": "^8",
    "tailwind-merge": "^2.5.2",
    "tailwindcss": "^4.1.13",
    "tailwindcss-animate": "^1.0.7",
    "typescript": "^5"
  }
}
</file>

<file path="src/features/test/backend/route.ts">
import type { Hono } from "hono";
import { stream } from "hono/streaming";
import { zValidator } from "@hono/zod-validator";
import { getAuth } from "@hono/clerk-auth";
import type { AppEnv } from "@/backend/hono/context";
import { respond, failure } from "@/backend/http/response";
import {
  createTestRequestSchema,
  testListQuerySchema,
  testParamsSchema,
} from "./schema";
import {
  createTest,
  getTestList,
  getTestDetail,
  initTest,
  getTestForStream,
  updateTestAnalysis,
  deleteTest,
} from "./service";
import { testErrorCodes } from "./error";
import { getOrCreateUser } from "@/features/auth/backend/helpers";
import { streamSajuAnalysis } from "@/lib/gemini/client";
import { streamOpenAIAnalysis } from "@/lib/openai/client";
import type { GeminiModel } from "@/lib/gemini/types";

export const registerTestRoutes = (app: Hono<AppEnv>) => {
  app.post(
    "/api/test/create",
    zValidator("json", createTestRequestSchema) as never,
    async (c) => {
      const auth = getAuth(c);

      if (!auth?.userId) {
        return respond(
          c,
          failure(401, testErrorCodes.INTERNAL_ERROR, "인증이 필요합니다")
        );
      }

      const supabase = c.get("supabase");
      const logger = c.get("logger");
      const userResult = await getOrCreateUser(supabase, logger, auth.userId);

      if (!userResult.success) {
        return respond(
          c,
          failure(404, testErrorCodes.INTERNAL_ERROR, userResult.error)
        );
      }

      const body = await c.req.json();
      const parsed = createTestRequestSchema.parse(body);

      return respond(c, await createTest(c, userResult.user.id, parsed));
    }
  );

  app.get("/api/test/list", async (c) => {
    const auth = getAuth(c);

    if (!auth?.userId) {
      return respond(
        c,
        failure(401, testErrorCodes.INTERNAL_ERROR, "인증이 필요합니다")
      );
    }

    const supabase = c.get("supabase");
    const logger = c.get("logger");
    const userResult = await getOrCreateUser(supabase, logger, auth.userId);

    if (!userResult.success) {
      return respond(
        c,
        failure(404, testErrorCodes.INTERNAL_ERROR, userResult.error)
      );
    }

    const query = testListQuerySchema.parse({
      name: c.req.query("name"),
      limit: c.req.query("limit"),
      offset: c.req.query("offset"),
    });

    return respond(c, await getTestList(supabase, userResult.user.id, query));
  });

  app.get("/api/test/:id", async (c) => {
    const auth = getAuth(c);

    if (!auth?.userId) {
      return respond(
        c,
        failure(401, testErrorCodes.INTERNAL_ERROR, "인증이 필요합니다")
      );
    }

    const supabase = c.get("supabase");
    const logger = c.get("logger");
    const userResult = await getOrCreateUser(supabase, logger, auth.userId);

    if (!userResult.success) {
      return respond(
        c,
        failure(404, testErrorCodes.INTERNAL_ERROR, userResult.error)
      );
    }

    const params = testParamsSchema.parse({ id: c.req.param("id") });

    return respond(c, await getTestDetail(supabase, userResult.user.id, params.id));
  });

  app.post(
    "/api/test/init",
    zValidator("json", createTestRequestSchema) as never,
    async (c) => {
      const auth = getAuth(c);

      if (!auth?.userId) {
        return respond(
          c,
          failure(401, testErrorCodes.INTERNAL_ERROR, "인증이 필요합니다")
        );
      }

      const supabase = c.get("supabase");
      const logger = c.get("logger");
      const userResult = await getOrCreateUser(supabase, logger, auth.userId);

      if (!userResult.success) {
        return respond(
          c,
          failure(404, testErrorCodes.INTERNAL_ERROR, userResult.error)
        );
      }

      const body = await c.req.json();
      const parsed = createTestRequestSchema.parse(body);

      return respond(c, await initTest(c, userResult.user.id, parsed));
    }
  );

  app.post("/api/test/stream/:id", async (c) => {
    const auth = getAuth(c);

    if (!auth?.userId) {
      return c.json({ success: false, message: "인증이 필요합니다" }, 401);
    }

    const supabase = c.get("supabase");
    const logger = c.get("logger");
    const userResult = await getOrCreateUser(supabase, logger, auth.userId);

    if (!userResult.success) {
      return c.json({ success: false, message: userResult.error }, 404);
    }

    const testId = c.req.param("id");
    const params = testParamsSchema.parse({ id: testId });

    const testResult = await getTestForStream(supabase, userResult.user.id, params.id);

    if (!testResult.ok) {
      const errorResult = testResult as { ok: false; status: number; error: { message: string } };
      return c.json(
        { success: false, message: errorResult.error.message },
        errorResult.status as any
      );
    }

    const testData = testResult.data;
    const body = await c.req.json().catch(() => ({}));
    const model = (body.model || "gemini-2.0-flash") as GeminiModel;

    c.header("Content-Type", "text/event-stream");
    c.header("Cache-Control", "no-cache");
    c.header("Connection", "keep-alive");

    return stream(c, async (streamWriter) => {
      let fullText = "";
      const sajuInput = {
        name: testData.name,
        birth_date: testData.birth_date,
        birth_time: testData.birth_time,
        gender: testData.gender,
      };

      const runGeminiStream = async (): Promise<{ success: boolean; error?: any }> => {
        try {
          logger.info("Starting Gemini stream", { test_id: params.id });
          const geminiResult = await streamSajuAnalysis(sajuInput, model);

          for await (const chunk of geminiResult.textStream) {
            fullText += chunk;
            await streamWriter.write(`data: ${JSON.stringify({ text: chunk })}\n\n`);
          }

          await geminiResult.response;

          if (fullText.length === 0) {
            return { success: false, error: { message: "No content generated" } };
          }

          return { success: true };
        } catch (error) {
          return { success: false, error };
        }
      };

      const geminiStreamResult = await runGeminiStream();

      if (geminiStreamResult.success) {
        await updateTestAnalysis(supabase, params.id, fullText);
        await streamWriter.write(`data: ${JSON.stringify({ done: true })}\n\n`);
        logger.info("Stream completed with Gemini", { test_id: params.id });
      } else {
        const geminiError = geminiStreamResult.error;
        const errorMessage = geminiError?.message || "";
        const errorBody = geminiError?.responseBody || geminiError?.lastError?.responseBody || "";
        const statusCode = geminiError?.statusCode || geminiError?.lastError?.statusCode;

        const isQuotaError =
          statusCode === 429 ||
          errorMessage.includes("quota") ||
          errorMessage.includes("rate") ||
          errorMessage.includes("RESOURCE_EXHAUSTED") ||
          errorBody.includes("RESOURCE_EXHAUSTED");

        if (isQuotaError) {
          logger.warn("Gemini quota exceeded, falling back to OpenAI", {
            test_id: params.id,
            error: errorMessage,
          });

          try {
            fullText = "";
            await streamWriter.write(
              `data: ${JSON.stringify({ fallback: "openai", message: "Gemini 쿼터 초과로 GPT-4.1-mini로 전환합니다..." })}\n\n`
            );

            const openaiResult = await streamOpenAIAnalysis(sajuInput);

            for await (const chunk of openaiResult.textStream) {
              fullText += chunk;
              await streamWriter.write(`data: ${JSON.stringify({ text: chunk })}\n\n`);
            }

            await updateTestAnalysis(supabase, params.id, fullText);
            await streamWriter.write(`data: ${JSON.stringify({ done: true })}\n\n`);
            logger.info("Stream completed with OpenAI fallback", { test_id: params.id });
          } catch (openaiError) {
            logger.error("OpenAI fallback also failed", openaiError);
            await streamWriter.write(
              `data: ${JSON.stringify({ error: "AI 서비스를 사용할 수 없습니다. 잠시 후 다시 시도해주세요." })}\n\n`
            );
          }
        } else {
          logger.error("Gemini stream error (non-quota)", geminiError);
          await streamWriter.write(
            `data: ${JSON.stringify({ error: "스트리밍 중 오류가 발생했습니다" })}\n\n`
          );
        }
      }
    });
  });

  app.delete("/api/test/:id", async (c) => {
    const auth = getAuth(c);

    if (!auth?.userId) {
      return respond(
        c,
        failure(401, testErrorCodes.INTERNAL_ERROR, "인증이 필요합니다")
      );
    }

    const supabase = c.get("supabase");
    const logger = c.get("logger");
    const userResult = await getOrCreateUser(supabase, logger, auth.userId);

    if (!userResult.success) {
      return respond(
        c,
        failure(404, testErrorCodes.INTERNAL_ERROR, userResult.error)
      );
    }

    const params = testParamsSchema.parse({ id: c.req.param("id") });

    return respond(c, await deleteTest(supabase, userResult.user.id, params.id));
  });
};
</file>

</files>
